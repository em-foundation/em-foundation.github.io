{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#the-em-programming-language","title":"The EM\u2122 Programming Language","text":"<p>Welcome to the world of EM \u2013 a novel programming language and runtime environment targeting resource-constrained embedded systems. To increase your understanding of the language and its runtime, this site documents all aspects of the EM software platform.</p> <p>If you haven't already done so, we strongly suggest starting with Introducing EM which offers a 10,000' overview of the EM language and runtime \u2013 even if you just can't wait to install the EM software and start hacking some code\u2009!!!\u00a0\u00a0  Besides rationalizing the need for EM, this overview introduces concepts as well as defines terminology used throughout the site.</p> <p>Building upon this introductory overview of EM, we've then organized the remaining documents found at this site as follows:</p> Installing EM software and hardware required to build and run EM programs Using EM language immersion through a graduated series of portable EM examples Porting EM steps required for (re-)targeting EM to a specific HW/SW environment Advancing EM deep-dives into specific facets of the EM platform Click here to see more (less) details <p>We'll often insert additional commentary on the material at hand in this collapsible format, providing deeper insights into some aspect of EM. While (hopefully) insightful, feel free to skip these comments at any time.</p> <p>So follow me, and let the journey begin\u2009.... </p>"},{"location":"about/","title":"About EM","text":""},{"location":"install/","title":"Getting started with EM","text":"<p>Using the EM language and its runtime requires a cross-development environment, in which hosted tooling will build\u2009/\u2009load executable EM programs onto target hardware. For the host, you'll use a PC running Windows, Linux, or MacOS(1); for the target, you can choose any MCU board for which an <code>em$distro</code> package already exists.</p> <ol> <li>MacOS support coming in 1Q24</li> </ol> <p>The EM SDK (described next) comprises a set of development artifacts which you'll download and install onto your host computer. Before doing so, however, you'll to install\u2009/\u2009upgrade the following tooling environments on your PC:</p> Node.js version 16.3.0 or later execute <code>node</code> <code>--version</code> to verify VS Code version 1.80.0 or later execute <code>code</code> <code>--version</code> to verify Windows <p>If you don't already have a recent version of the Git Bash shell, you should also install Git for Windows.\u00a0  To verify your setup, ensure that the <code>node</code> and <code>code</code> commands from the previous table operate correctly under Git Bash. </p> <p>Do not proceed forward if these verification checks should fail\u2009!!!</p>"},{"location":"install/#software-development-kit","title":"Software development kit","text":"<p>To install the EM SDK, execute the following commands from your PC's shell:</p> <code>mkdir ~/.em-sdk</code> <code># folder</code> <code>npm set @openem:registry=https://us-west2-npm.pkg.dev/openem/openem-npm/</code> <code># registry</code> <code>npm install @openem/em-sdk --prefix ~/.em-sdk</code> <code># package</code> <p>Command  creates a special folder named<code>.em-sdk</code> under the <code>$HOME</code> or <code>%HOMEPATH%</code> directory on your PC, which we'll refer to as <code>\u00abEM-SDK\u00bb</code> going forward.</p> <p>Command  configures the Node Package Manager [<code>npm</code>] with the URL housing packages inside the <code>@openem</code> scope; this binding persists, so you only have to execute this command once.</p> <p>Command  installs the latest version of the <code>@openem/em-sdk</code> package, populating your <code>\u00abEM-SDK\u00bb</code> folder with a number of artifacts.</p> <p>Under the <code>\u00abEM-SDK\u00bb</code> folder you'll now find a sub-folder named <code>tools</code>, which contains C\u2009/\u2009C++ compilers as well as emulation utilities \u2013 all used internally by EM to build\u2009/\u2009load executable target programs. Already located in a well-known place on your PC, EM requires no further setup of these tools.</p> <p>Your <code>\u00abEM-SDK\u00bb</code> folder also contains the EM Builder VS Code extension \u2013 found within a file named <code>em-builder-vers.vsix</code>, where <code>vers</code> encodes the extension's major\u2009/\u2009minor\u2009/\u2009patch version number followed by a timestamp.  <code>\u00abEM-SDK\u00bb</code> additionally contains a VS Code profile used with EM Builder, found in the file named <code>EM.code-profile</code>\u2009.</p> More about the Node Package Manager <p>While used extensively within the JavaScript community, the <code>npm</code> infrastructure can in fact manage delivery of any type of software artifact \u2013 including binaries; <code>npm</code> also supports life-cycle scripts included within any package and executed (say) upon installation.  In our case, <code>install.js</code> scripts populate the <code>\u00abEM-SDK\u00bb</code> folder.</p> <p>Command  also creates two <code>package*.json</code> files along with a <code>node_modules</code> folder in <code>\u00abEM-SDK\u00bb</code>:\u00a0  the former records the version of <code>@openem/em-sdk</code> current installed; the latter holds the package itself plus others upon which it depends.\u00a0 Execute <code>npm</code> <code>list</code> <code>--all</code> inside your <code>\u00abEM-SDK\u00bb</code> folder to see the package-dependency tree.</p> <p>Once installed, executing the command <code>npm</code> <code>update</code> from within <code>\u00abEM-SDK\u00bb</code> will ensure you have the latest version of the <code>@openem/em-sdk</code> package.  If a complete re-install becomes necessary, first remove <code>\u00abEM-SDK\u00bb</code> and execute <code>npm</code> <code>cache</code> <code>clear</code> <code>--force</code> and then repeat commands  through  shown above.</p>"},{"location":"install/#target-mcu-hardware","title":"Target MCU hardware","text":"<p>The EM SDK \u2013 which you've just installed \u2013 contains all of the tools required to build\u2009/\u2009load EM programs targeting any of the following boards; you won't need to download any additional, vendor-specific software.\u00a0  While we encourage you to purchase one (or more) of these boards, you can still learn a great deal about EM without having any target hardware.</p> **\u2009FAST-TRACK\u2009**LP-EM-CC2340R5Board #2Board #3 <p>Nothing to buy, of course\u2009!!!\u00a0  You can still build executable programs using any <code>em$distro</code> package within the EM SDK; you just can't load these programs onto target hardware.</p> <p>Familiarize yourself, however, with the Setups available for one (or more) of the target hardware tracks enumerated above.</p> <p>The Texas Instruments CC2340R5 wireless MCU features an Arm Cortex-M0+ CPU together with a familiar suite of peripherals \u2013 including a generic 2.4\u2009GHz radio with BLE 5.x support.  Texas Instruments also offers an inexpensive LP-EM-CC2340R5 evaluation board in their familiar LaunchPad format \u2013 available from TI as well as their distributors.</p> <p>You should also purchase this emulator board from TI \u2013 unless you already own a \"classic\" TI LaunchPad with on-board XDS110 support.  In that case, you can easily connect this legacy LP to your new LP-EM-CC2340R5 board using a cable supplied by TI.  If you haven't used an XDS110 before, run the <code>one_time_setup</code> script found in <code>\u00abEM-SDK\u00bb/tools/ti-uniflash</code>.</p> <p>The <code>ti.cc23xx</code> distro supports the following Setups for the EM-SDK tools:</p> <code>ti.cc23xx/gcc</code> GCC 10.3, optimized for space <code>ti.cc23xx/gcc_sram</code> GCC 10.3, optimized for space, code\u2009+\u2009consts in SRAM <code>ti.cc23xx/segger</code> CLANG\u2009/\u2009LLVM 14.0, optimized for space <code>ti.cc23xx/segger_sram</code> CLANG\u2009/\u2009LLVM 14.0, optimized for space, code\u2009+\u2009consts in SRAM <code>ti.cc23xx/default</code> == <code>ti.cc23xx/segger</code> <p>TBD \u2013 open for suggestions</p> <p>TBD \u2013 open for suggestions</p> <p>As we pivot to installing EM Builder, we'll soon illustrate how to select one of the Setups associated with the distros supporting these hardware options.</p> <p>Which MCU board(s) would you want to see EM support\u2009???</p>"},{"location":"install/#em-builder-extension","title":"EM Builder extension","text":"<p>At this stage, we can launch VS Code and install its EM Builder extension. To begin, first create an empty folder anywhere on your PC (outside of <code>\u00abEM-SDK\u00bb</code>); this folder will serve as your initial VS Code workspace.</p> <p>Next, enter the command <code>code</code> <code>workspace</code> to launch VS Code (where <code>workspace</code> represents a path to the folder created above).\u00a0 Unless you've already installed EM Builder, you'll see something like the default <code>Welcome</code> layout shown within the following screen capture:</p> <p></p> <p></p> Importing Profiles <p></p> <p></p> Importing Profiles <p>Prior to installing EM Builder, however, you'll have to import the file <code>EM.code-profile</code> found under your <code>\u00abEM-SDK\u00bb</code> folder. To illustrate the process, watch the Importing Profiles animation above by clicking the  button atop this screen capture.</p> <p>When ready, follow the same steps [\u2009Profiles\u2009&gt;\u2009Import Profiles...\u2009] on your own installation of VS Code.  You can rewind this animation by clicking the  button whenever it appears atop the screen capture.\u00a0  Hint \u2013 you can also click on the image itself to enlarge the view.</p> <p>With the EM profile in place, you can finally install the EM Builder extension as illustrated in the following animation:</p> <p></p> <p></p> Installing Extensions <p></p> <p></p> Installing Extensions <p>To review these steps, you'll select Extensions: Install from VSIX from the VS Code Command Palette and locate the (latest) <code>em-builder-vers.vsix</code> file under the <code>\u00abEM-SDK\u00bb</code> folder. At the end of this sequence, VS Code will prompt you to select one of the EM Setups as illustrated in the following animation.</p> <p></p> <p></p> Selecting Setups <p></p> <p></p> Selecting Setups <p>You should select a \"default\" configuration when the EM Setup dropdown appears \u2013 even if you've chosen the **\u2009FAST-TRACK\u2009** option for your target MCU hardware.  If you do plan to connect a target board, however, you'll also need to assign an appropriate value to the <code>ConsolePort</code> parameter found in the workspace <code>local.properties</code> file as follows: </p> <p></p> Setting ConsolePort   <p>Finding the actual value for the <code>ConsolePort</code> parameter depends, of course, on utilities specific to your PC's operating system as well as some help from your board's documentation.</p>"},{"location":"install/#ready-set-go","title":"Ready, Set, Go\u00a0!!!","text":"<p>With everything now in place, the time has come to start Using EM\u2009.\u2003Happy coding\u2009!!! \u2002 </p> <p></p>"},{"location":"advancing/","title":"Deep-dive into different facets of EM","text":"<p>This document comprises a collection of independent articles focusing on different facets of the EM language and runtime.  So pick a topic of interest and then dive right in\u2009!!!</p> Command-line interface Managing EM from within the shell Energy Consumption Optimizing power over time Language Syntax Navigating EM syntax diagrams Performance benchmarks Adapting CoreMark\u00ae to EM <p>What other aspects of EM should we tackle next\u2009???</p> <p></p>"},{"location":"advancing/bench/","title":"Adapting CoreMark\u00ae to EM","text":"<p>Under Construction \u2014 estimated completion in 1Q24 \u2009 </p> <p></p>"},{"location":"advancing/cli/","title":"Managing EM from within the shell","text":"<p>Under Construction \u2014 estimated completion in 1Q24 \u2009 </p> <p></p>"},{"location":"advancing/energy/","title":"Optimizing power over time","text":"<p>We put forth a rather bold proposition in Using EM:\u2003 If you can't see the problem, you can't fix it\u2009!!!\u00a0 As we toured the EM runtime, logic captures for each example program gave you an important perspective \u2013 that of program state over the course of time.  Informally termed \"real-time debug\", this kind of logic trace proves invaluable to both quantify program execution time at sub-\u03bcs resolution, as well as to verify proper sequencing of program execution.</p> <p>This article expands this proposition into the domain of energy consumption \u2013 by now tracing MCU power over the course of time.  With many resource-constrained MCUs targeting always-on applications that run using batteries and\u2009/\u2009or harvested energy, power profiles captured by a precision energy analyzer nicely complement the \"real-time debug\" traces captured by a logic-state analyzer.</p> <p>Until recently, the cost of a high-quality energy analyzer would often exceed $10,000 \u2013 far beyond most of our budgets.  The recent arrival of the Joulescope JS220 precision analyzer does, however, afford order-of-magnitude relief on pricing.  And the STM32 Power Shield offers an even more affordable option at &lt;\u2009$100.</p> <p>Help wanted \u2013 someone familiar with the STM32 Power Shield</p> <p>For now, though, we'll stick with the Joulescope JS220 as our energy analyzer.  And even if you don't own a JS220, we recommend downloading the (free) Joulescope UI software as well as the original power capture files presented throughout this article.</p>"},{"location":"advancing/energy/#mcu-power-modes","title":"Mcu power modes","text":"<p>The Tour 10 \u2013 Logic Capture seen here in Using EM introduced the terms \"lite-sleep\" and \"deep-sleep\" corresponding to distinct marks on <code>dbgB</code>.  Recalling the  Alarm1P example, this program enters the MCU's deep-sleep mode <code>%%[b:2]</code> after calling <code>alarm.wakeup</code>.  But after calling <code>AppLed.wink</code> \u2013 which internally pauses execution for a much shorter period of time \u2013 the program instead enters the MCU's lite-sleep mode <code>%%[b:1]</code>.</p> <p>While each vendor often has their own jargon for these power modes (<code>IDLE</code>, <code>PAUSE</code>, <code>SLEEP</code>, <code>STOP</code>, <code>SUSPEND</code>, \u2026\u2009), we'll uniformally use the following terminology when measuring power across different MCUs supported by EM:</p> <code>ACTIVE</code> CPU core running \u2013 MCU peripherals powered on when needed by CPU <code>PAUSE</code> CPU core idling \u2013 MCU peripherals powered on when needed for CPU wakeup <code>SLEEP</code> CPU + most peripherals powered off \u2013 wakeup via special \"always-on\" peripherals <code>HIBERNATE</code> entire MCU powered off \u2013 CPU \"reset\" interrupt triggered by external HW devices only <p>As application software transitions amongst these modes, the power required to operate the MCU can range from milliwatts [<code>ACTIVE</code>] to microwatts [<code>SLEEP</code>] \u2013 and even down to nanowatts [<code>HIBERNATE</code>] if the application wishes to suspend execution indefintely.</p> <p>To quantify these MCU power modes on your target board, we'll use the  Button3P program highlighted in Tour\u200906 to obtain these readings.  The Button3P Power Capture image below marks four distinct points during program execution, where we'll use the JS220 to measure the amperage instanteneously drawn by the MCU. </p> <p> \u00a0 We've pressed <code>appBut</code> for almost 4\u2009s, with the program testing <code>appBut</code> every 100\u2009ms. [<code>PAUSE</code>] </p> <p> \u00a0 Crossing the 4\u2009s threshold, the program now blinks <code>sysLed</code> for 40\u2009ms using a busy-wait loop. [<code>ACTIVE</code>]</p> <p> \u00a0 The program sleeps until the next button event, even though <code>appBut</code> itself remains pressed. [<code>SLEEP</code>]</p> <p> \u00a0 With the button now released, the program remains asleep while drawing even less current. [<code>SLEEP</code>]</p> LP-EM-CC2340R5Board #2Board #3 <p> Button3P Power Capture   <p>TBD \u2013 open for suggestions</p> <p>TBD \u2013 open for suggestions</p> <p>Because the JS200 samples at a relatively slow 1\u2009MHz rate (compared with the CPU clock), the capture around marker  shows a series of ripples spaced 100\u2009ms apart which in fact correspond to very brief CPU wakeups from <code>PAUSE</code> to sample <code>appBut</code>; a similar train of blips occurs around markers  and , which here represent an internal duty-cycled recharge of the MCU's DC/DC converter or LDO regulator.</p> <p>By in large, these current measurements align with specifications found in the MCU vendor's datasheet.  Do note, however, that the <code>ACTIVE</code> reading recorded at marker  includes current drawn by the board's LED as well as the CPU itself.  </p>"},{"location":"advancing/energy/#measuring-energy","title":"Measuring energy","text":"<p>While important, MCU power specifications such as [<code>SLEEP</code> <code>=</code> <code>1.5</code> <code>\u03bcA</code>] or even more generalized forms such as [<code>ACTIVE</code> <code>=</code> <code>53</code> <code>\u03bcA</code> <code>/</code> <code>MHz</code>] say absolutely nothing about the overall energy efficiency of an ultra-low-power embedded system built around this particular MCU.  To gain this perspective, we must simultaneously consider the software running on the MCU and answer critical questions such as: </p> <p>Once awakened, how quickly can our application software go back to sleep\u2009?!?!</p> <p>By knowing the amount of time a program spends in the various MCU power modes, we can begin to quantify the overall energy efficiency of an embedded system.  To illustrate the methodology we'll apply to measure energy consumption, consider the following JS220 capture of the  Alarm1P example, which complements the logic capture found here:</p> LP-EM-CC2340R5Board #2Board #3 <p> Alarm1P Power Capture \u2013 Flash  <p>EM Setup:\u00a0<code>ti.cc23xx/segger_default</code></p> <p>TBD \u2013 open for suggestions</p> <p>TBD \u2013 open for suggestions</p> <p> <code>Alarm1P</code> spends the majority of its time in <code>SLEEP</code>, typical of many embedded applications.</p> <p> \u00a0 Once <code>ACTIVE</code>, the program calls <code>AppLed.wink</code> and then enters <code>PAUSE</code> mode for 100\u2009ms;</p> <p> \u00a0 awoken from <code>PAUSE</code>, the program calls <code>alarm.wakeup</code> and moves from <code>ACTIVE</code> to <code>SLEEP</code> mode.</p> <p> \u00a0 The energy (in millijoules) consumed during this 100+\u2009ms <code>SLEEP</code>\u2009-\u2009<code>ACTIVE</code>\u2009-\u2009<code>PAUSE</code>\u2009-\u2009<code>ACTIVE</code>\u2009-\u2009<code>SLEEP</code> interval.</p> <p> \u00a0 The energy (in millijoules) consumed over an arbitrary 10\u2009s interval encompassing six wakeups from <code>SLEEP</code>.</p> <p>While time intervals  and  differ by a factor of 100, the total energy [\u2009<code>mJ</code>\u2009] consumed over these intervals differ by only a factor of \u2248\u20096.  Needless to say, decreasing the number of wakeups over a given timeframe will always improve overall energy efficiency.  Often, though, application requirements will dictate the frequency of these wakeup intervals \u2013 as high as once per second in many embedded systems.</p>"},{"location":"advancing/energy/#less-code-less-energy","title":"Less code, less energy","text":"<p>Introducing EM hypothesized that reducing code size could have a potentially dramatic impact on the size, power, and cost of future MCU silicon.  Focusing on the dimension of power for now \u2013 and targeting legacy MCUs \u2013 we can already quantify the relationship between \"less code\" and \"less energy\".</p> <p>Needless to say, minimizing the number of CPU instructions executed while <code>ACTIVE</code> will only reduce overall energy consumption \u2013 assuming our software still meets a given set of application requirements.  With its uncanny ability to reduce code size, the EM language and runtime should benchmark quite favorably against more conventional C\u2009/\u2009C++ RTOS platforms such as Zephyr.</p> <p>Help wanted \u2013 embedded programmer familiar with Zephyr</p> <p>Setting aside the larger \"EM vs C\u2009/\u2009C++\" discussion for now, we'll focus instead on a very effective technique for reducing energy consumption using the same Alarm1P program executing on the same target MCU board.\u00a0  Quite simply, the EM runtime will automatically copy the\u2009<code>.text</code> and\u2009<code>.const</code> program sections into fast, on-chip SRAM at startup \u2013 rather than leaving this readonly code\u2009+\u2009data in Flash memory, where they conventionally reside.</p> <p>To quantify the impact of this change, compare the following Alarm1P Power Capture with our earlier baseline \u2013 paying close attention to the total energy [\u2009<code>mJ</code>\u2009] consumed at intervals  and  in each capture.</p> LP-EM-CC2340R5Board #2Board #3 <p> Alarm1P Power Capture \u2013 SRAM   <p>EM Setup:\u00a0<code>ti.cc23xx/segger_sram</code></p> <p>TBD \u2013 open for suggestions</p> <p>TBD \u2013 open for suggestions</p> <p>While we do see a modest 10% gain in energy efficiency here, don't forget that the <code>Alarm1P</code> program actually fetches very few instructions \u2013 with the MCU remaining in a (lower-power) <code>PAUSE</code> mode for most of interval .\u00a0  Imagine, though, a duty-cycled \"sleepy\" application that executes a non-trivial mix of math functions and control code when <code>ACTIVE</code>:\u00a0 significant improvements during interval  would also lower overall energy consumption reported at .</p> <p>With modern MCUs clocked at \u2248\u200950\u2009-\u2009150\u2009MHz\u2009, these architectures invariably employ a HW cache to mitigate wait-states which would otherwise stall the CPU when fetching instructions or constants directly from slower flash memory.  But SRAM has no such limitations, as this class of memory can easily sustain read rates in excess of 500\u2009MHz\u2009.  The CPU hence runs at maximum efficiency, allowing the application to re-enter <code>SLEEP</code> that much sooner.</p> <p>Assuming the program image can actually fit within SRAM \u2013 a far more scarce  resource than flash \u2013 the EM distro for your target MCU board can actually disable the flash memory and its HW cache during <code>em$startup</code> to further reduce ambient power.  Paradoxically, running the CPU at its highest possible clock rate will often decrease overall energy consumption when executing \u2013 again, by minimizing the amount of time spent in the <code>ACTIVE</code> mode.</p> <p>In the course of time, we'll have additional articles under Advancing EM that benchmark more sophisticated EM applications that nevertheless can execute entirely from on-chip SRAM.  Meanwhile, contemplate the following:</p> <p>Knowing EM applications need only a small SRAM to run, how might we architect future MCUs\u2009???</p> <p></p>"},{"location":"advancing/syntax/","title":"Navigating EM syntax diagrams","text":"<p>The following \"railroad track\" diagram captures the complete syntax of EM.  Automatically generated from the actual grammar used by the language translator, you can click on any of the blue rectangles (such as <code>Unit</code> or <code>TypeSpec</code>) and navigate to the definition of these non-terminal elements; the cyan ovals represent terminal tokens scanned by an underlying lexer.</p> <p>Hint</p> <p>Your browser will not maintain history as you navigate through this diagram. To save time scrolling back to the top of diagram, simply reload the entire window.</p> <p></p>"},{"location":"cargo/","title":"Index","text":""},{"location":"cargo/#em-bundles","title":"EM bundles","text":""},{"location":"cargo/em.core/","title":"Index","text":""},{"location":"cargo/em.core/#bundle-emcore","title":"bundle em.core","text":""},{"location":"cargo/em.core/em.hal/","title":"Index","text":""},{"location":"cargo/em.core/em.hal/#package-emhal","title":"package em.hal","text":""},{"location":"cargo/em.core/em.hal/BusyWaitI/","title":"BusyWaitI","text":""},{"location":"cargo/em.core/em.hal/BusyWaitI/#unit-busywaiti","title":"unit BusyWaitI","text":"em.hal/BusyWaitI.em<pre><code>package em.hal\ninterface BusyWaitI\n#   ^| abstraction of a spin-loop\nfunction wait(usecs: uint32)\n#   ^| enter a spin-loop\n#   ^| @usecs - duration in microseconds\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/BusyWaitN/","title":"BusyWaitN","text":""},{"location":"cargo/em.core/em.hal/BusyWaitN/#unit-busywaitn","title":"unit BusyWaitN","text":"em.hal/BusyWaitN.em<pre><code>package em.hal\nimport BusyWaitI\nmodule BusyWaitN: BusyWaitI\n#   ^| Nil implementation of the BusyWaitI interface\nend\ndef wait(usecs)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/ButtonI/","title":"ButtonI","text":""},{"location":"cargo/em.core/em.hal/ButtonI/#unit-buttoni","title":"unit ButtonI","text":"em.hal/ButtonI.em<pre><code>package em.hal\ninterface ButtonI\n#   ^| abstraction of a pressable button\ntype OnPressedCB: function()\n#   ^| signature of a button's callback function\nfunction isPressed(): bool\n#   ^| test whether this button is currently pressed\nfunction onPressed(cb: OnPressedCB, minDurationMs: uint16 = 100, maxDurationMs: uint16 = 4000)\n#   ^| bind a callback to this button\n#   ^| @cb - callback function, executed when this button is pressed\n#   ^| @minDurationMs - minimum time in millisecs before executing this button's callback\n#   ^| @maxDurationMs - maximum time in millisecs, after which this button's callback is executed\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/ButtonN/","title":"ButtonN","text":""},{"location":"cargo/em.core/em.hal/ButtonN/#unit-buttonn","title":"unit ButtonN","text":"em.hal/ButtonN.em<pre><code>package em.hal\nimport ButtonI\nmodule ButtonN: ButtonI\n#   ^| Nil implementation of the ButtonI interface\nend\ndef isPressed()\nreturn false\nend\ndef onPressed(cb, minDurationMs, maxDurationMs)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/ConsoleUartI/","title":"ConsoleUartI","text":""},{"location":"cargo/em.core/em.hal/ConsoleUartI/#unit-consoleuarti","title":"unit ConsoleUartI","text":"em.hal/ConsoleUartI.em<pre><code>package em.hal\ninterface ConsoleUartI host function setBaudH(rate: uint32)\nfunction flush()\nfunction put(data: uint8)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/ConsoleUartN/","title":"ConsoleUartN","text":""},{"location":"cargo/em.core/em.hal/ConsoleUartN/#unit-consoleuartn","title":"unit ConsoleUartN","text":"em.hal/ConsoleUartN.em<pre><code>package em.hal\nimport ConsoleUartI\nmodule ConsoleUartN: ConsoleUartI\n#   ^| Nil implementation of the ConsoleUartI interface\nend\ndef setBaudH(rate)\nend\ndef flush()\nend\ndef put(data)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/CopierI/","title":"CopierI","text":""},{"location":"cargo/em.core/em.hal/CopierI/#unit-copieri","title":"unit CopierI","text":"em.hal/CopierI.em<pre><code>package em.hal\ninterface CopierI\nfunction exec(dst: ptr_t, src: ptr_t, cnt: uint16)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/FlashI/","title":"FlashI","text":""},{"location":"cargo/em.core/em.hal/FlashI/#unit-flashi","title":"unit FlashI","text":"em.hal/FlashI.em<pre><code>package em.hal\ninterface FlashI\nhost function getSectorSizeH(): uint32\nhost function getWriteChunkH(): uint32\nfunction erase(addr: addr_t, upto: addr_t = 0)\nfunction write(addr: addr_t, data: ptr_t, len: uint32): addr_t\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/FlashN/","title":"FlashN","text":""},{"location":"cargo/em.core/em.hal/FlashN/#unit-flashn","title":"unit FlashN","text":"em.hal/FlashN.em<pre><code>package em.hal\nimport FlashI\nmodule FlashN: FlashI\n#   ^| Nil implementation of the FlashI interface\nend\ndef getSectorSizeH()\nreturn 0\nend\ndef getWriteChunkH()\nreturn 0\nend\ndef erase(addr, upto)\nend\ndef write(addr, data, len)\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/GlobalInterruptsI/","title":"GlobalInterruptsI","text":""},{"location":"cargo/em.core/em.hal/GlobalInterruptsI/#unit-globalinterruptsi","title":"unit GlobalInterruptsI","text":"em.hal/GlobalInterruptsI.em<pre><code>package em.hal\n#! Interface implemented by a GlobalInterrupts module for a device.\ninterface GlobalInterruptsI type Key: uarg_t\n#! Disables interrupts and saves state\nfunction disable(): Key\n#! Enables interrupts\nfunction enable()\n#! Restores interrupts to previous state\nfunction restore(key: Key)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/GlobalInterruptsN/","title":"GlobalInterruptsN","text":""},{"location":"cargo/em.core/em.hal/GlobalInterruptsN/#unit-globalinterruptsn","title":"unit GlobalInterruptsN","text":"em.hal/GlobalInterruptsN.em<pre><code>package em.hal\nimport GlobalInterruptsI\nmodule GlobalInterruptsN: GlobalInterruptsI\n#   ^| Nil implementation of the GlobalInterruptsI interface\nend\ndef disable()\nreturn 0\nend\ndef enable()\nend\ndef restore(key)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/GpioEdgeDetectMinI/","title":"GpioEdgeDetectMinI","text":""},{"location":"cargo/em.core/em.hal/GpioEdgeDetectMinI/#unit-gpioedgedetectmini","title":"unit GpioEdgeDetectMinI","text":"em.hal/GpioEdgeDetectMinI.em<pre><code>package em.hal\nimport GpioI\ninterface GpioEdgeDetectMinI: GpioI #   ^| extends the GpioI abstraction with edge-detection features\ntype Handler: function ()\n#   ^| signature of an edge-detection function\nhost function setDetectHandlerH(h: Handler)\n#   ^| bind a handler to this GPIO at build-time\nfunction clearDetect()\n#   ^| clear (acknowledge) any edge-detection by this GPIO\nfunction disableDetect()   \n#   ^| disable edge-detection by this GPIO\nfunction enableDetect()\n#   ^| enable edge-detection by this GPIO\nfunction setDetectFallingEdge()\n#   ^| detect high-to-low transitions by this GPIO\nfunction setDetectRisingEdge()\n#   ^| detect low-to-high transitions by this GPIO\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/GpioEdgeDetectMinN/","title":"GpioEdgeDetectMinN","text":""},{"location":"cargo/em.core/em.hal/GpioEdgeDetectMinN/#unit-gpioedgedetectminn","title":"unit GpioEdgeDetectMinN","text":"em.hal/GpioEdgeDetectMinN.em<pre><code>package em.hal\nimport GpioEdgeDetectMinI\nmodule GpioEdgeDetectMinN: GpioEdgeDetectMinI\n#   ^| Nil implementation of the GpioEdgeDetectMinI interface\nend\ndef set()\nend\ndef clear()\nend\ndef toggle()\nend\ndef get()\nreturn false\nend\ndef makeInput()\nend\ndef isInput()\nreturn false\nend\ndef makeOutput()\nend\ndef isOutput()\nreturn false\nend\ndef functionSelect(select)\nend\ndef setInternalPullup(state)\nend\ndef pinId()\nreturn 0\nend\ndef reset()\nend\ndef enableDetect()\nend\ndef disableDetect()\nend\ndef clearDetect()\nend\ndef setDetectRisingEdge()\nend\ndef setDetectFallingEdge()\nend\ndef setDetectHandlerH(h)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/GpioI/","title":"GpioI","text":""},{"location":"cargo/em.core/em.hal/GpioI/#unit-gpioi","title":"unit GpioI","text":"em.hal/GpioI.em<pre><code>package em.hal\ninterface GpioI\n#   ^| abstraction of a GPIO pin\nfunction clear()\n#   ^| clear the value of this GPIO (low)\nfunction functionSelect (select: uint8)\n#   ^| select an alternative function of this GPIO\nfunction get(): bool\n#   ^| get the value of this GPIO\nfunction isInput(): bool\n#   ^| test if this GPIO is an input pin\nfunction isOutput(): bool\n#   ^| test if this GPIO is an output pin\nfunction makeInput()\n#   ^| make this GPIO an input pin\nfunction makeOutput()\n#   ^| make this GPIO an output pin\nfunction pinId(): int16\n#   ^| Return the pin ID of this GPIO\nfunction reset()\n#   ^| Reset this GPIO\nfunction set()\n#   ^| set the value of this GPIO (high)\nfunction setInternalPullup (state: bool)\n#   ^| enable/disable the internalpullup for this GPIO\nfunction toggle()\n#   ^| toggle the value of this GPIO\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/GpioN/","title":"GpioN","text":""},{"location":"cargo/em.core/em.hal/GpioN/#unit-gpion","title":"unit GpioN","text":"em.hal/GpioN.em<pre><code>package em.hal\nimport GpioI\nmodule GpioN: GpioI\n#   ^| Nil implementation of the GpioI interface\nend\ndef set()\nend\ndef clear()\nend\ndef toggle()\nend\ndef get()\nreturn false\nend\ndef makeInput()\nend\ndef isInput()\nreturn false\nend\ndef makeOutput()\nend\ndef isOutput()\nreturn false\nend\ndef functionSelect(select)\nend\ndef setInternalPullup(state)\nend\ndef pinId()\nreturn 0\nend\ndef reset()\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/HostUartI/","title":"HostUartI","text":""},{"location":"cargo/em.core/em.hal/HostUartI/#unit-hostuarti","title":"unit HostUartI","text":"em.hal/HostUartI.em<pre><code>package em.hal\nimport ConsoleUartI\ninterface HostUartI: ConsoleUartI\ntype RxHandler: function(b: uint8)\nfunction disable()\nfunction enable()\nfunction get(): uint8\nhost function setRxHandlerH(handler: RxHandler)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/HostUartN/","title":"HostUartN","text":""},{"location":"cargo/em.core/em.hal/HostUartN/#unit-hostuartn","title":"unit HostUartN","text":"em.hal/HostUartN.em<pre><code>package em.hal\nimport HostUartI\nmodule HostUartN: HostUartI\n#   ^| Nil implementation of the HostUartI interface\nend\ndef setBaudH(rate)\n## TODO -- implement\nend\ndef flush()\n## TODO -- implement\nend\ndef put(data)\n## TODO -- implement\nend\ndef disable()\n## TODO -- implement\nend\ndef enable()\n## TODO -- implement\nend\ndef get()\n## TODO -- implement\nreturn 0\nend\ndef setRxHandlerH(handler)\n## TODO -- implement\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/IdleI/","title":"IdleI","text":""},{"location":"cargo/em.core/em.hal/IdleI/#unit-idlei","title":"unit IdleI","text":"em.hal/IdleI.em<pre><code>package em.hal\n#! Should be implemented by an Idle module\ninterface IdleI  #! This function defines how the system idles\nfunction exec()\n#! This function is called during \"warm\" wakeups\nfunction wakeup()\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/IdleN/","title":"IdleN","text":""},{"location":"cargo/em.core/em.hal/IdleN/#unit-idlen","title":"unit IdleN","text":"em.hal/IdleN.em<pre><code>package em.hal\nimport IdleI\nmodule IdleN: IdleI\n#   ^| Nil implementation of the IdleI interface\nend\ndef exec()\nend\ndef wakeup()\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/InterruptSourceI/","title":"InterruptSourceI","text":""},{"location":"cargo/em.core/em.hal/InterruptSourceI/#unit-interruptsourcei","title":"unit InterruptSourceI","text":"em.hal/InterruptSourceI.em<pre><code>package em.hal\n#! Generally implemented by an Interrupt Template used to \"create\" interrupts\ninterface InterruptSourceI type Handler: function()\n#! Sets the handler function for a particular interrupt\nhost function setHandlerH(h: Handler)\n#! Enables a particular interrupt\nfunction enable()\n#! Disables a particular interrupt\nfunction disable()\n#! Clears the interrupt flag   \nfunction clear()\n#! True if the interrupt is enabled\nfunction isEnabled(): bool\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/IntrVecI/","title":"IntrVecI","text":""},{"location":"cargo/em.core/em.hal/IntrVecI/#unit-intrveci","title":"unit IntrVecI","text":"em.hal/IntrVecI.em<pre><code>package em.hal\ninterface IntrVecI\ntype ExceptionHandler: function(vecNum: uint32, retAddr: addr_t)\nhost function bindExceptionHandlerH(handler: ExceptionHandler)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/LedI/","title":"LedI","text":""},{"location":"cargo/em.core/em.hal/LedI/#unit-ledi","title":"unit LedI","text":"em.hal/LedI.em<pre><code>package em.hal\ninterface LedI\n#   ^| abstraction of an LED\nfunction isOn(): bool\n#   ^| test if the LED is on\nfunction off()\n#   ^| turn the LED off\nfunction on()\n#   ^| turn the LED on\nfunction toggle()\n#   ^| toggle the LED\nfunction wink(msecs: uint16)\n#   ^| turn the LED on/off\n#   ^| @msecs duration in milliseconds\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/LedN/","title":"LedN","text":""},{"location":"cargo/em.core/em.hal/LedN/#unit-ledn","title":"unit LedN","text":"em.hal/LedN.em<pre><code>package em.hal\nimport LedI\nmodule LedN: LedI\n#   ^| Nil implementation of the LedI interface\nend\ndef isOn()\nreturn false\nend\ndef on()\nend\ndef off()\nend\ndef toggle()\nend\ndef wink(usecs)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/McuI/","title":"McuI","text":""},{"location":"cargo/em.core/em.hal/McuI/#unit-mcui","title":"unit McuI","text":"em.hal/McuI.em<pre><code>package em.hal\n#! Implemented by an Mcu module\ninterface McuI const ADMIN_RESET: int8 = -1\nconst HOST_RESET:  int8 = -2\nconst COLD_RESET:  int8 = -3\nconst FIRST_RESET: int8 = -4\nconfig mclkFrequency: uint32\nfunction getResetCode(): int8\nfunction getStashAddr(): ptr_t\nfunction isWarm(): bool\nfunction readEui48(dst: uint8*)\n#! Perform startup and shutdown operations specific for a particular Mcu\nfunction reset(code: int8 = 0)\nfunction startup()\nfunction shutdown()\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/McuInfoI/","title":"McuInfoI","text":""},{"location":"cargo/em.core/em.hal/McuInfoI/#unit-mcuinfoi","title":"unit McuInfoI","text":"em.hal/McuInfoI.em<pre><code>package em.hal\ninterface McuInfoI\nfunction readBatMv(): uint16\nfunction readTempC(): int8\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/McuInfoN/","title":"McuInfoN","text":""},{"location":"cargo/em.core/em.hal/McuInfoN/#unit-mcuinfon","title":"unit McuInfoN","text":"em.hal/McuInfoN.em<pre><code>package em.hal\nimport McuInfoI\nmodule McuInfoN: McuInfoI\n#   ^| Nil implementation of the McuInfoI interface\nend\ndef readBatMv()\nreturn 0\nend\ndef readTempC()\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/McuN/","title":"McuN","text":""},{"location":"cargo/em.core/em.hal/McuN/#unit-mcun","title":"unit McuN","text":"em.hal/McuN.em<pre><code>package em.hal\nimport McuI\nmodule McuN: McuI\nend\ndef getResetCode()\nreturn 0\nend\ndef getStashAddr()\nreturn null\nend\ndef isWarm()\nreturn false\nend\ndef readEui48(dst)\nend\ndef reset(code)\nend\ndef startup()\nend\ndef shutdown()\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/MsCounterI/","title":"MsCounterI","text":""},{"location":"cargo/em.core/em.hal/MsCounterI/#unit-mscounteri","title":"unit MsCounterI","text":"em.hal/MsCounterI.em<pre><code>package em.hal\ninterface MsCounterI\nfunction start()\nfunction stop(): uint32\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/MsCounterN/","title":"MsCounterN","text":""},{"location":"cargo/em.core/em.hal/MsCounterN/#unit-mscountern","title":"unit MsCounterN","text":"em.hal/MsCounterN.em<pre><code>package em.hal\nimport MsCounterI\nmodule MsCounterN: MsCounterI\n#   ^| Nil implementation of the MsCounterI interface\nend\ndef start()\nend\ndef stop()\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/OneShotMilliI/","title":"OneShotMilliI","text":""},{"location":"cargo/em.core/em.hal/OneShotMilliI/#unit-oneshotmillii","title":"unit OneShotMilliI","text":"em.hal/OneShotMilliI.em<pre><code> package em.hal\ninterface OneShotMilliI\n#   ^| abstraction of a one-shot timer with millisecond resolution\ntype Handler: function(arg: ptr_t)\n#   ^| handler function signature\nfunction disable()\n#   ^| disables the timer\nfunction enable(msecs: uint32, handler: Handler, arg: ptr_t = null) \n#   ^| enables the timer to expire in msecs milliseconds\n#   ^| @msecs - duration in millisecs before expiration\n#   ^| @handler - handler function called upon expiration \n#   ^| @arg - optional value passed to the handler\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/OneShotMilliN/","title":"OneShotMilliN","text":""},{"location":"cargo/em.core/em.hal/OneShotMilliN/#unit-oneshotmillin","title":"unit OneShotMilliN","text":"em.hal/OneShotMilliN.em<pre><code>package em.hal\nimport OneShotMilliI\nmodule OneShotMilliN: OneShotMilliI\n#   ^| Nil implementation of the OneShotMilliI interface\nend\ndef disable()\nend\ndef enable(msecs, handler, arg)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/PollerI/","title":"PollerI","text":""},{"location":"cargo/em.core/em.hal/PollerI/#unit-polleri","title":"unit PollerI","text":"em.hal/PollerI.em<pre><code>package em.hal\ninterface PollerI\n#       ^| abstration of periodic polling\ntype PollFxn: function(): bool\n#       ^| signature of a boolean-valued polling function\nfunction poll(rateMs: uint16, count: uint16, fxn: PollFxn): uint16 #       ^| initiates a polling sequence\n#       ^| @rateMs - idle time in milliseconds between pollings\n#       ^| @count - maximum number of polling attempts\n#       ^| @fxn - the polling function itself\n#       ^| @return - the number of polling attempts remaining (success if &gt;0)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/PollerN/","title":"PollerN","text":""},{"location":"cargo/em.core/em.hal/PollerN/#unit-pollern","title":"unit PollerN","text":"em.hal/PollerN.em<pre><code>package em.hal\nimport PollerI\nmodule PollerN: PollerI\n#   ^| Nil implementation of the PollerI interface\nend\ndef poll(rateMs, count, fxn)\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/RandI/","title":"RandI","text":""},{"location":"cargo/em.core/em.hal/RandI/#unit-randi","title":"unit RandI","text":"em.hal/RandI.em<pre><code>package em.hal\ninterface RandI\nfunction gen(): uint32\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/RandN/","title":"RandN","text":""},{"location":"cargo/em.core/em.hal/RandN/#unit-randn","title":"unit RandN","text":"em.hal/RandN.em<pre><code>package em.hal\nimport RandI\nmodule RandN: RandI\n#   ^| Nil implementation of the RandI interface\nend\ndef gen()\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/SpiMasterI/","title":"SpiMasterI","text":""},{"location":"cargo/em.core/em.hal/SpiMasterI/#unit-spimasteri","title":"unit SpiMasterI","text":"em.hal/SpiMasterI.em<pre><code>package em.hal\ninterface SpiMasterI\nfunction activate()\nfunction deactivate()\nfunction flush()\nfunction get(): uint8\nfunction put(data: uint8)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/TimeoutI/","title":"TimeoutI","text":""},{"location":"cargo/em.core/em.hal/TimeoutI/#unit-timeouti","title":"unit TimeoutI","text":"em.hal/TimeoutI.em<pre><code>package em.hal\ninterface TimeoutI\nfunction active(): bool\nfunction cancel()\nfunction set(msecs: uint32)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/TimeoutN/","title":"TimeoutN","text":""},{"location":"cargo/em.core/em.hal/TimeoutN/#unit-timeoutn","title":"unit TimeoutN","text":"em.hal/TimeoutN.em<pre><code>package em.hal\nimport TimeoutI\nmodule TimeoutN: TimeoutI\n#   ^| Nil implementation of the TimeoutI interface\nend\ndef active()\nreturn false\nend\ndef cancel()\nend\ndef set(msecs)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/UptimerI/","title":"UptimerI","text":""},{"location":"cargo/em.core/em.hal/UptimerI/#unit-uptimeri","title":"unit UptimerI","text":"em.hal/UptimerI.em<pre><code>package em.hal\ninterface UptimerI\ntype Time: struct\nsecs: uint32\nsubs: uint32\nticks: uint32\nend\nfunction calibrate(secs256: uint32, ticks: uint32): uint16\nfunction read(): Time&amp;\nfunction resetSync()\nfunction trim(): uint16\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/UptimerN/","title":"UptimerN","text":""},{"location":"cargo/em.core/em.hal/UptimerN/#unit-uptimern","title":"unit UptimerN","text":"em.hal/UptimerN.em<pre><code>package em.hal\nimport UptimerI\nmodule UptimerN: UptimerI\n#   ^| Nil implementation of the UptimerI interface\nend\ndef calibrate(secs256, ticks)\nreturn 0\nend\ndef read()\nreturn null\nend\ndef resetSync()\nend\ndef trim()\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/UsThreshI/","title":"UsThreshI","text":""},{"location":"cargo/em.core/em.hal/UsThreshI/#unit-usthreshi","title":"unit UsThreshI","text":"em.hal/UsThreshI.em<pre><code>package em.hal\ninterface UsThreshI\nfunction pause()\nfunction set(usecs: uint16)\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/WakeupTimerI/","title":"WakeupTimerI","text":""},{"location":"cargo/em.core/em.hal/WakeupTimerI/#unit-wakeuptimeri","title":"unit WakeupTimerI","text":"em.hal/WakeupTimerI.em<pre><code>package em.hal\ninterface WakeupTimerI\n#   ^| abstraction of a free-running wakeup-timer (RTC)\ntype Handler: function()\n#   ^| handler function signature\nfunction disable()\n#   ^| disables any pending wakeup from the timer\nfunction enable(thresh: uint32, handler: Handler)\n#   ^| enables a future wakeup from the timer\n#   ^| @thresh - an internal timer threshold value\n#   ^| @handler - the function called when reaching the threshold\nfunction secs256ToTicks(secs256: uint32): uint32\n#   ^| converts secs256 to logical timer ticks\nfunction ticksToThresh(ticks: uint32): uint32\n#   ^| converts timer ticks to an internal timer threshold value\nfunction timeToTicks(secs: uint32, subs: uint32): uint32\n#   ^| converts secs+subs time value to logical timer ticks\n#   ^| @secs - the seconds component of the time value\n#   ^| @subs - the sub-seconds component of the time value\n#   ^| @return - time value represented as logic timer ticks\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/WakeupTimerN/","title":"WakeupTimerN","text":""},{"location":"cargo/em.core/em.hal/WakeupTimerN/#unit-wakeuptimern","title":"unit WakeupTimerN","text":"em.hal/WakeupTimerN.em<pre><code>package em.hal\nimport WakeupTimerI\nmodule WakeupTimerN: WakeupTimerI\n#   ^| Nil implementation of the WakeupTimerI interface\nend\ndef disable()\nend\ndef enable(thresh, handler)\nend\ndef getMsecs()\nreturn 0\nend\ndef getSecs256(oTicks)\nreturn 0\nend\ndef ticksFromTime(secs256, msecs, oThresh)\nreturn 0\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/WatchdogI/","title":"WatchdogI","text":""},{"location":"cargo/em.core/em.hal/WatchdogI/#unit-watchdogi","title":"unit WatchdogI","text":"em.hal/WatchdogI.em<pre><code>package em.hal\ninterface WatchdogI\ntype Handler: function()\nfunction didBite(): bool\nfunction disable()\nfunction enable(secs: uint16, handler: Handler)\nfunction pet()\nend\n</code></pre>"},{"location":"cargo/em.core/em.hal/WatchdogN/","title":"WatchdogN","text":""},{"location":"cargo/em.core/em.hal/WatchdogN/#unit-watchdogn","title":"unit WatchdogN","text":"em.hal/WatchdogN.em<pre><code>package em.hal\nimport WatchdogI\nmodule WatchdogN: WatchdogI\n#   ^| Nil implementation of the WatchdogI interface\nend\ndef didBite()\nreturn false\nend\ndef disable()\nend\ndef enable(secs, handler)\nend\ndef pet()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/","title":"Index","text":""},{"location":"cargo/em.core/em.lang/#package-emlang","title":"package em.lang","text":""},{"location":"cargo/em.core/em.lang/Assert/","title":"Assert","text":""},{"location":"cargo/em.core/em.lang/Assert/#unit-assert","title":"unit Assert","text":"em.lang/Assert.em<pre><code>package em.lang\nimport AssertProviderI\nimport AssertProviderN\nmodule Assert\nproxy Provider: AssertProviderI\nfunction enabled(): bool\nfunction trigger(upath: atom_t, line: uint16, msg: atom_t = 0, arg1: iarg_t = 0, arg2: iarg_t = 0)\nend\ndef em$configure()\nProvider ?= AssertProviderN\nend\ndef enabled()\nreturn Provider.enabled()\nend\ndef trigger(upath, line, msg, arg1, arg2)\nProvider.trigger(upath, line, msg, arg1, arg2) if enabled()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/AssertProviderI/","title":"AssertProviderI","text":""},{"location":"cargo/em.core/em.lang/AssertProviderI/#unit-assertprovideri","title":"unit AssertProviderI","text":"em.lang/AssertProviderI.em<pre><code>package em.lang\ninterface AssertProviderI\nfunction enabled(): bool\nfunction trigger(upath: atom_t, line: uint16, msg: atom_t, arg1: iarg_t, arg2: iarg_t)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/AssertProviderN/","title":"AssertProviderN","text":""},{"location":"cargo/em.core/em.lang/AssertProviderN/#unit-assertprovidern","title":"unit AssertProviderN","text":"em.lang/AssertProviderN.em<pre><code>package em.lang\nimport AssertProviderI\nmodule AssertProviderN: AssertProviderI\nend\ndef enabled()\nreturn false\nend\ndef trigger(upath, line, msg, arg1, arg2)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/Atom/","title":"Atom","text":""},{"location":"cargo/em.core/em.lang/Atom/#unit-atom","title":"unit Atom","text":"em.lang/Atom.em<pre><code>package em.lang\nmodule Atom\nconfig NULL_A: atom_t = @\"&lt;&lt;null&gt;&gt;\"\nconfig UNDEFINED_A: atom_t = @\"&lt;&lt;undefined&gt;&gt;\"\nfunction fromString(str: string, oatom: atom_t*): bool\nfunction hasTable(): bool\nfunction toString(atom: atom_t): string\nprivate:\nconst MASK: addr_t = 0x80000000\nconfig tableFlag: bool\nend\ndef em$construct()\ntableFlag = ^^!!em$props.get(em$session.PROP_ATOM_TABLE)^^\nend\ndef fromString(str, oatom)\nauto saddr = &lt;addr_t&gt;str\nreturn false if tableFlag || (saddr &amp; MASK) == 0\n    *oatom = &lt;atom_t&gt;saddr\nreturn true\nend\ndef hasTable()\nreturn tableFlag\nend\ndef toString(atom)\nreturn tableFlag ? ^^em$atoms[atom]^^ : &lt;string&gt;((&lt;addr_t&gt;atom) | MASK)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/BuildC/","title":"BuildC","text":""},{"location":"cargo/em.core/em.lang/BuildC/#unit-buildc","title":"unit BuildC","text":"em.lang/BuildC.em<pre><code>package em.lang\ncomposite BuildC\nconfig arch: string\nconfig bootFlash: bool\nconfig bootLoader: bool\nconfig compiler: string\nconfig cpu: string\nconfig jlinkDev: string\nconfig mcu: string\nconfig optimize: string\nprivate:\nvar curPval: string\nfunction getProp(pname: string): string\nend\ndef em$preconfigure()\narch ?= curPval if getProp(\"em.build.Arch\")\nbootFlash ?= true if getProp(\"em.build.BootFlash\")\nbootLoader ?= true if getProp(\"em.lang.BootLoader\")\ncompiler ?= curPval if getProp(\"em.build.Compiler\")\ncpu ?= curPval if getProp(\"em.build.Cpu\")\njlinkDev ?= curPval if getProp(\"em.build.JlinkDev\")\nmcu ?= curPval if getProp(\"em.build.Mcu\")\noptimize ?= curPval if getProp(\"em.build.Optimize\")\nend\ndef getProp(pname)\nreturn curPval = ^^em$props.get^^(pname, null)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/BuilderI/","title":"BuilderI","text":""},{"location":"cargo/em.core/em.lang/BuilderI/#unit-builderi","title":"unit BuilderI","text":"em.lang/BuilderI.em<pre><code>package em.lang\nhost interface BuilderI\ntype CompileInfo: struct\nerrMsgs: string[]\nimageSizes: string\nprocStat: int8\nend\ntype TypeInfoDesc: uint8[2]\ntype TypeInfo: struct\nARG:    TypeInfoDesc\nCHAR:   TypeInfoDesc\nINT:    TypeInfoDesc\nINT8:   TypeInfoDesc\nINT16:  TypeInfoDesc\nINT32:  TypeInfoDesc\nLONG:   TypeInfoDesc\nPTR:    TypeInfoDesc\nSHORT:  TypeInfoDesc\nSIZE:   TypeInfoDesc\nend\nfunction compile(buildDir: string): CompileInfo&amp;\nfunction getTypeInfo(): TypeInfo&amp;\nfunction populate(buildDir: string, sysFlag: bool)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/CompositeI/","title":"CompositeI","text":""},{"location":"cargo/em.core/em.lang/CompositeI/#unit-compositei","title":"unit CompositeI","text":"em.lang/CompositeI.em<pre><code>package em.lang\ninterface CompositeI\nhost function em$configure()\nhost function em$preconfigure()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/Console/","title":"Console","text":""},{"location":"cargo/em.core/em.lang/Console/#unit-console","title":"unit Console","text":"em.lang/Console.em<pre><code>package em.lang\nimport ConsoleProviderI\nmodule Console\nproxy Provider: ConsoleProviderI\nconfig noPrint: bool\nfunction print(fmt: string, a1: iarg_t = 0, a2: iarg_t = 0, a3: iarg_t = 0, a4: iarg_t = 0, a5: iarg_t = 0, a6: iarg_t = 0)\nfunction wrC(data: char)\nfunction wrN(data: num_t)\nfunction wrP(data: ptr_t)\nfunction wrT(data: string)\nfunction wrIA(data: iarg_t)\nfunction wrUA(data: uarg_t)\nfunction wrI8(data: int8)\nfunction wrI16(data: int16)\nfunction wrI32(data: int32)\nfunction wrU8(data: uint8)\nfunction wrU16(data: uint16)\nfunction wrU32(data: uint32)\nend\ndef em$generateCode(prefix)\n    |-&gt; #define em$print em_lang_Console::print\nend\ndef print(fmt, a1, a2, a3, a4, a5, a6)\nif !noPrint\nProvider.print(fmt, a1, a2, a3, a4, a5, a6)\nend\nend\ndef wrC(data)\nProvider.put(data)\nend\ndef wrN(data)\nProvider.put(0x8F)\nauto ba = &lt;uint8[]&gt;(&amp;data)\nfor auto i = 0; i &lt; sizeof&lt;num_t&gt;; i++\nProvider.put(ba[i])\nend\nProvider.flush()\nend\ndef wrP(data)\nwrU32(&lt;uint32&gt;data)\nend\ndef wrT(data)\nProvider.put(0x80)\nauto cp = &lt;char*&gt;data\nfor ;;\nauto ch = *cp++\nwrC(ch)\nreturn if ch == 0      \nend\nend\ndef wrIA(data)\nwrU16(&lt;uint16&gt;data)\nend\ndef wrUA(data)\nwrU16(&lt;uint16&gt;data)\nend\ndef wrI8(data)\nwrU8(&lt;uint8&gt;data)\nend\ndef wrI16(data)\nwrU16(&lt;uint16&gt;data)\nend\ndef wrI32(data)\nwrU32(&lt;uint32&gt;data)\nend\ndef wrU8(data)\nProvider.put(0x81)\nProvider.put(data)\nProvider.flush()\nend\ndef wrU16(data)\nProvider.put(0x82)\nauto b = &lt;uint8&gt; ((data &gt;&gt; 8) &amp; 0xFF)\nProvider.put(b)\nb = &lt;uint8&gt; ((data &gt;&gt; 0) &amp; 0xFF)\nProvider.put(b)\nProvider.flush()\nend\ndef wrU32(data)\nProvider.put(0x84)\nauto b = &lt;uint8&gt; ((data &gt;&gt; 24) &amp; 0xFF)\nProvider.put(b)\nb = &lt;uint8&gt; ((data &gt;&gt; 16) &amp; 0xFF)\nProvider.put(b)\nb = &lt;uint8&gt; ((data &gt;&gt; 8) &amp; 0xFF)\nProvider.put(b)\nb = &lt;uint8&gt; ((data &gt;&gt; 0) &amp; 0xFF)\nProvider.put(b)\nProvider.flush()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/ConsoleProviderI/","title":"ConsoleProviderI","text":""},{"location":"cargo/em.core/em.lang/ConsoleProviderI/#unit-consoleprovideri","title":"unit ConsoleProviderI","text":"em.lang/ConsoleProviderI.em<pre><code>package em.lang\ninterface ConsoleProviderI\nfunction flush()\nfunction print(fmt: string, a1: iarg_t = 0, a2: iarg_t = 0, a3: iarg_t = 0, a4: iarg_t = 0, a5: iarg_t = 0, a6: iarg_t = 0)\nfunction put(data: uint8)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/ConsoleProviderN/","title":"ConsoleProviderN","text":""},{"location":"cargo/em.core/em.lang/ConsoleProviderN/#unit-consoleprovidern","title":"unit ConsoleProviderN","text":"em.lang/ConsoleProviderN.em<pre><code>package em.lang\nimport ConsoleProviderI\nmodule ConsoleProviderN: ConsoleProviderI\nend\ndef flush()\nend\ndef print(fmt, a1, a2, a3, a4, a5, a6)\nend\ndef put(data)\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/Debug/","title":"Debug","text":""},{"location":"cargo/em.core/em.lang/Debug/#unit-debug","title":"unit Debug","text":"em.lang/Debug.em<pre><code>package em.lang\nimport DebugPinI\nmodule Debug\nproxy Pin_a: DebugPinI\nproxy Pin_b: DebugPinI\nproxy Pin_c: DebugPinI\nproxy Pin_d: DebugPinI\nfunction getNumPins(): uint8\nfunction sleepEnter()\nfunction sleepLeave()\nfunction startup()\nprivate:\nend\ndef em$configure()\nem$used ?= true\nend\ndef getNumPins()\nreturn 4\nend\ndef sleepEnter()\nPin_a.reset()\nPin_b.reset()\nPin_c.reset()\nPin_d.reset()\nend\ndef sleepLeave()\nstartup()\nend\ndef startup()\nPin_a.startup()\nPin_b.startup()\nPin_c.startup()\nPin_d.startup()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/DebugPinI/","title":"DebugPinI","text":""},{"location":"cargo/em.core/em.lang/DebugPinI/#unit-debugpini","title":"unit DebugPinI","text":"em.lang/DebugPinI.em<pre><code>package em.lang\ninterface DebugPinI\nfunction clear()\nfunction get(): bool\nfunction set()\nfunction toggle()\nfunction pulse()\nfunction mark(k: uint8 = 0)\nfunction reset()\nfunction startup()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/Math/","title":"Math","text":""},{"location":"cargo/em.core/em.lang/Math/#unit-math","title":"unit Math","text":"em.lang/Math.em<pre><code>package em.lang\n#! This module is only available for use on the host.\n#! It contains some standard math functions.\nhost module Math\nconfig PI: num_t\n#! Returns the absolute value of x\nfunction abs(x: num_t): num_t\n#! Returns the smallest integer greater than or equal to x\nfunction ceil(x: num_t): num_t\n#! Returns the cos of x\nfunction cos(x: num_t): num_t\n#! Returns the largest integer less than or equal to x\nfunction floor(x: num_t): num_t\n#! Returns the logarithm (base 10) of x\nfunction log2(x: num_t): num_t\n#! Returns the logarithm (base 10) of x\nfunction log10(x: num_t): num_t\n#! Returns the value of x to the y power\nfunction pow(x: num_t, y: num_t): num_t\n#! Returns the rounded value of x\nfunction round(x: num_t): num_t\n#! Returns the sin of x\nfunction sin(x: num_t): num_t\nend\ndef em$configure()\nPI ?= ^^global.Math.PI^^\nend\ndef abs(x)\nreturn ^^global.Math.abs(x)^^\nend\n# If x = 19.1 this function will return 20\ndef ceil(x)\nreturn ^^global.Math.ceil(x)^^\nend\ndef cos(x)\nreturn ^^global.Math.cos(x)^^\nend\n# If x = 19.6 this function will return 19\ndef floor(x)\nreturn ^^global.Math.floor(x)^^\nend\ndef log2(x)\nreturn ^^global.Math.log2(x)^^\nend\ndef log10(x)\nreturn ^^global.Math.LOG10E * global.Math.log(x)^^\nend\ndef pow(x, y)\nreturn ^^global.Math.pow(x, y)^^\nend\ndef round(x)\nreturn ^^global.Math.round(x)^^\nend\ndef sin(x)\nreturn ^^global.Math.sin(x)^^\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/ModuleI/","title":"ModuleI","text":""},{"location":"cargo/em.core/em.lang/ModuleI/#unit-modulei","title":"unit ModuleI","text":"em.lang/ModuleI.em<pre><code>package em.lang\ninterface ModuleI\ntype io32_t: uint32 volatile*\nhost config em$exclude: bool\nhost config em$export: bool\nhost config em$traceGrp: string\nhost config em$used: bool\nconfig em$tracePri: uint8\nhost function em$configure()\nhost function em$construct()\ntemplate em$generateCode(prefix: string)\nfunction em$fail()\nfunction em$halt()\nfunction em$reset()\nfunction em$run()\nfunction em$shutdown()\nfunction em$startup()\nfunction em$startupDone()\nhost function em$uses__()\nend\n</code></pre>"},{"location":"cargo/em.core/em.lang/TemplateI/","title":"TemplateI","text":""},{"location":"cargo/em.core/em.lang/TemplateI/#unit-templatei","title":"unit TemplateI","text":"em.lang/TemplateI.em<pre><code>package em.lang\nhost interface TemplateI function em$cacheDirty(ctimeMs: num_t): bool\ntemplate em$generateUnit(pkgName: string, unitName: string)\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/","title":"Index","text":""},{"location":"cargo/em.core/em.mcu/#package-emmcu","title":"package em.mcu","text":""},{"location":"cargo/em.core/em.mcu/Common/","title":"Common","text":""},{"location":"cargo/em.core/em.mcu/Common/#unit-common","title":"unit Common","text":"em.mcu/Common.em<pre><code>package em.mcu\nfrom em.hal import BusyWaitI\nfrom em.hal import GlobalInterruptsI\nfrom em.hal import IdleI\nfrom em.hal import McuI\nfrom em.hal import MsCounterI\nfrom em.hal import RandI\nfrom em.hal import WatchdogI\nmodule Common\n#   ^| collection of proxies implementing MCU abstractions\nproxy BusyWait: BusyWaitI\nproxy GlobalInterrupts: GlobalInterruptsI\nproxy Idle: IdleI proxy Mcu: McuI    proxy MsCounter: MsCounterI    proxy Rand: RandI\nproxy Watchdog: WatchdogI\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/CommonC/","title":"CommonC","text":""},{"location":"cargo/em.core/em.mcu/CommonC/#unit-commonc","title":"unit CommonC","text":"em.mcu/CommonC.em<pre><code>package em.mcu\nfrom em.hal import BusyWaitN\nfrom em.hal import GlobalInterruptsN\nfrom em.hal import IdleN\nfrom em.hal import McuN\nfrom em.hal import MsCounterN\nfrom em.hal import RandN\nfrom em.hal import WatchdogN\nfrom em.mcu import Common\ncomposite CommonC\nend\ndef em$configure()\nCommon.BusyWait ?= BusyWaitN\nCommon.GlobalInterrupts ?= GlobalInterruptsN\nCommon.Idle ?= IdleN\nCommon.Mcu ?= McuN\nCommon.MsCounter ?= MsCounterN\nCommon.Rand ?= RandN\nCommon.Watchdog ?= WatchdogN\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/ConsoleUart/","title":"ConsoleUart","text":""},{"location":"cargo/em.core/em.mcu/ConsoleUart/#unit-consoleuart","title":"unit ConsoleUart","text":"em.mcu/ConsoleUart.em<pre><code>package em.mcu\nfrom em.hal import ConsoleUartI\nfrom em.hal import ConsoleUartN\nmodule ConsoleUart: ConsoleUartI\nproxy Impl: ConsoleUartI\nend\ndef em$configure()\nImpl ?= ConsoleUartN\nend\ndef setBaudH(rate)\nImpl.setBaudH(rate)\nend\ndef flush()\nImpl.flush()\nend\ndef put(data)\nImpl.put(data)\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/Copier/","title":"Copier","text":""},{"location":"cargo/em.core/em.mcu/Copier/#unit-copier","title":"unit Copier","text":"em.mcu/Copier.em<pre><code>package em.mcu\nfrom em.hal import CopierI\nmodule Copier: CopierI\nproxy Impl: CopierI\nend\ndef exec(dst, src, cnt)\nImpl.exec(dst, src, cnt)\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/Info/","title":"Info","text":""},{"location":"cargo/em.core/em.mcu/Info/#unit-info","title":"unit Info","text":"em.mcu/Info.em<pre><code>package em.mcu\nfrom em.hal import McuInfoI\nmodule Info: McuInfoI\nproxy Impl: McuInfoI\nend\ndef readBatMv()\nreturn Impl.readBatMv()\nend\ndef readTempC()\nreturn Impl.readTempC()\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/Poller/","title":"Poller","text":""},{"location":"cargo/em.core/em.mcu/Poller/#unit-poller","title":"unit Poller","text":"em.mcu/Poller.em<pre><code>package em.mcu\nfrom em.hal import PollerI\nmodule Poller: PollerI\nproxy Impl: PollerI\nfunction pause(timeMs: uint16)\nend\ndef pause(timeMs)\nImpl.poll(timeMs, 1, null)\nend\ndef poll(rateMs, count, fxn)\nreturn Impl.poll(rateMs, count, fxn)\nend\n</code></pre>"},{"location":"cargo/em.core/em.mcu/Timeout/","title":"Timeout","text":""},{"location":"cargo/em.core/em.mcu/Timeout/#unit-timeout","title":"unit Timeout","text":"em.mcu/Timeout.em<pre><code>package em.mcu\nfrom em.hal import TimeoutI\nmodule Timeout: TimeoutI\nproxy Impl: TimeoutI\nend\ndef active()\nreturn Impl.active()\nend\ndef cancel()\nImpl.cancel()\nend\ndef set(msecs)\nImpl.set(msecs)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/","title":"Index","text":""},{"location":"cargo/em.core/em.utils/#package-emutils","title":"package em.utils","text":""},{"location":"cargo/em.core/em.utils/AlarmMgr/","title":"AlarmMgr","text":""},{"location":"cargo/em.core/em.utils/AlarmMgr/#unit-alarmmgr","title":"unit AlarmMgr","text":"em.utils/AlarmMgr.em<pre><code>package em.utils\nfrom em.hal import WakeupTimerI\nimport EpochTime\nimport FiberMgr\nmodule AlarmMgr\n#   ^|\nproxy WakeupTimer: WakeupTimerI\n#   ^|\ntype Alarm: opaque\n#   ^|        host function initH(fiber: FiberMgr.Fiber&amp;)\n#   ^|        function active(): bool\n#   ^|        function cancel()\n#   ^|        function wakeup(secs256: uint32)\n#   ^|        function wakeupAt(secs256: uint32)\n#   ^|        end\nhost function createH(fiber: FiberMgr.Fiber&amp;): Alarm&amp;\n#   ^|\nprivate:\ndef opaque Alarm\nfiber: FiberMgr.Fiber&amp;\nthresh: uint32\nticks: uint32\nfunction setup(ticks: uint32)\nend\nfunction update(deltaTicks: uint32)\nfunction wakeupHandler: WakeupTimer.Handler\nvar alarmTab: Alarm[..]\nvar curAlarm: Alarm&amp;\nend\ndef createH(fiber)\nvar alarm: Alarm&amp; = alarmTab[alarmTab.length++]\nalarm.initH(fiber)\nreturn alarm\nend\ndef update(deltaTicks)\nWakeupTimer.disable()\nauto nxtAlarm = &lt;Alarm&amp;&gt;null\nvar maxTicks: uint32 = ~0       # largest uint32\nfor a in alarmTab\ncontinue if a.ticks == 0    # inactive alarm\na.ticks -= deltaTicks\nif a.ticks == 0             # expired alarm\na.fiber.post()\nelif a.ticks &lt; maxTicks\nnxtAlarm = a\nmaxTicks = a.ticks         end\nend\nreturn if nxtAlarm == null      # no active alarms\ncurAlarm = nxtAlarm\nWakeupTimer.enable(curAlarm.thresh, wakeupHandler)\nend\ndef wakeupHandler()\nupdate(curAlarm.ticks)\nend\ndef Alarm.initH(fiber)\nthis.fiber = fiber\nthis.ticks = 0\nend\ndef Alarm.active()\nreturn this.ticks != 0\nend\ndef Alarm.cancel()\nthis.ticks = 0\nupdate(0)\nend\ndef Alarm.setup(ticks)\nthis.thresh = WakeupTimer.ticksToThresh(ticks)\nthis.ticks = ticks\nupdate(0)\nend\ndef Alarm.wakeup(secs256)\nauto ticks = WakeupTimer.secs256ToTicks(secs256)\nthis.setup(ticks)\nend\ndef Alarm.wakeupAt(secs256)\nvar etSubs: uint32\nauto etSecs = EpochTime.getCurrent(&amp;etSubs)\nauto etTicks = WakeupTimer.timeToTicks(etSecs, etSubs)\nauto ticks = WakeupTimer.secs256ToTicks(secs256)\nthis.setup(ticks - (etTicks % ticks))\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/AppControl/","title":"AppControl","text":""},{"location":"cargo/em.core/em.utils/AppControl/#unit-appcontrol","title":"unit AppControl","text":"em.utils/AppControl.em<pre><code>package em.utils\nfrom em.mcu import Common\nimport BoardController\nimport EpochTime\nmodule AppControl\nfunction restart(status: int8)\nprivate:\ntype Stash: struct\nsecs: uint32\nsubs: uint32\nend\nfunction getStash(): Stash&amp;\nfunction doReset(code: int8)\nend\ndef em$startup()\nreturn if Common.Mcu.isWarm() || Common.Mcu.getResetCode() &lt; 0\nauto stash = getStash()\nEpochTime.setCurrent(stash.secs, stash.subs, false)\nend\ndef em$fail()\nBoardController.em$fail()\nend\ndef em$halt()\nBoardController.em$halt()\nend\ndef doReset(code)\nauto stash = getStash()\nstash.secs = EpochTime.getCurrent(&amp;stash.subs)\nCommon.Mcu.reset(code) \nend\ndef getStash()\nreturn Common.Mcu.getStashAddr()\nend\ndef restart(status)\ndoReset(status)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/AssertProvider/","title":"AssertProvider","text":""},{"location":"cargo/em.core/em.utils/AssertProvider/#unit-assertprovider","title":"unit AssertProvider","text":"em.utils/AssertProvider.em<pre><code>package em.utils\nfrom em.lang import AssertProviderI\nimport Error\nimport Logger\nmodule AssertProvider: AssertProviderI\nprivate:\nconfig assertMsgE: Logger.EventKind&amp;\nconfig assertSiteE: Logger.EventKind&amp;\nend\ndef em$construct()\nassertMsgE = Logger.declareEventH(\"ASSERT: $F\", \"*--*\")\nassertSiteE = Logger.declareEventH(\"ASSERT: $a, line %d\", \"*--*\")\nend\ndef enabled()\nreturn Logger.POLICY != Logger.Policy.NIL\nend\ndef trigger(upath, line, msg, arg1, arg2)\nassertSiteE.log(&lt;addr_t&gt;upath, line)\nassertMsgE.log(&lt;addr_t&gt;msg, &lt;addr_t&gt;arg1, &lt;addr_t&gt;arg2) if msg\nError.raise(Error.Kind.ASSERTION, 0, 0)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BasicListManager/","title":"BasicListManager","text":""},{"location":"cargo/em.core/em.utils/BasicListManager/#unit-basiclistmanager","title":"unit BasicListManager","text":"em.utils/BasicListManager.em<pre><code>package em.utils\nimport ListManagerI\n#! This module implements ListManagerI.\n#! It contains all the functions necessary to maintain a list of objects.\nmodule BasicListManager: ListManagerI\nprivate:\n# Representation of Element\ndef opaque Element next: Element&amp; volatile\nend\n# Representation of List\ndef opaque List first: Element&amp; volatile\nlast: Element&amp; volatile\nend\nend\n# Initially an Element is not a member of a List\ndef Element.init() \nthis.next = null\nend\n# Initially an Element is not a member of a List\ndef Element.initH() \nthis.next = null\nend\ndef Element.isActive() \nreturn &lt;uarg_t&gt; this.next\nend\n# Creates a head and tail pointer\ndef List.init() \nthis.first = this.last = &lt;Element&amp;&gt; &amp;this.first\nend\n# Creates a head and tail pointer\ndef List.initH() \nthis.first = this.last = &lt;Element&amp;&gt; &amp;this.first;\nend\n# The very first Element is pointed to by this.first and this.last.\n# Subsequent Elements are added to the end of the list by setting the\n# next pointer of the current last Element to the added Element then moving\n# the last pointer.    \ndef List.add(elem)\nthis.last.next = elem\nthis.last = elem\nelem.next = &lt;Element&amp;&gt; this\nend\n# Elements are removed from the front of the list by\n# setting a pointer equal to the this.first pointer,\n# then moving the this.first pointer to the next Element.\n# If the pointer then points to the List then that was the last\n# Element and reinitialize the list for adding Elements.\n# Otherwise just remove the Element.    \ndef List.get() \nauto elem = this.first\nthis.last = &lt;Element&amp;&gt;this if (this.first = elem.next) == &lt;Element&amp;&gt;this\nelem.next = null\nreturn elem\nend\ndef List.getAt(index)\nauto elem = this.first\nauto i = 0\nif this.hasElements()\nfor ;;\nbreak if i++ == index                elem = elem.next                break if elem == &lt;Element&amp;&gt; this\nend\nelem = null if elem == &lt;Element&amp;&gt; this\nelse elem = null\nend\nreturn elem\nend\n# This function returns the Element after the given Element\n# in the List, but does not remove it from the List.\ndef List.getNext(elem) \nreturn elem == this.last ? null : elem.next\nend\ndef List.hasElements() \nreturn (&lt;uarg_t&gt; this.first) ^ &lt;uarg_t&gt; this\nend\n# This function prints the index and address of each Element in the List\ndef List.print() \nauto elem = this.first\nauto i = 0\nif this.hasElements()\nfor ;;\nprintf \"elem%d %p\\n\", i++, elem\nelem = elem.next\nbreak if elem == &lt;Element&amp;&gt; this\nend\nelse printf \"list empty\\n\"\nend\nprintf \"\\n\" end\n# Performs a linear search through the list to find the Element\n# then removes it, updating the appropriate pointers.\ndef List.remove(elem)\nauto e = this.first\nif this.hasElements()\nif elem == this.first\nthis.first = this.first.next\nelse for ;; \nif e.next == elem\ne.next = elem.next                    break    end break if e == &lt;Element&amp;&gt; this\nend\nend\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BoardController/","title":"BoardController","text":""},{"location":"cargo/em.core/em.utils/BoardController/#unit-boardcontroller","title":"unit BoardController","text":"em.utils/BoardController.em<pre><code>package em.utils\nfrom em.hal import ConsoleUartI\nfrom em.hal import LedI\nfrom em.mcu import Common\nfrom em.mcu import ConsoleUart\nimport ConsoleProtocol\nmodule BoardController\nproxy Led: LedI\nproxy Uart: ConsoleUartI\nconfig blinkRate: uint32 = 50000\nprivate:    \nfunction blink(times: uint8, usecs: uint32)\nend\ndef em$configure()\nUart ?= ConsoleUart\nend\ndef em$reset()\nCommon.Mcu.startup() \nend\ndef em$startupDone()\nreturn if Common.Mcu.isWarm()\nLed.off()\nblink(2, blinkRate)\nUart.flush()\nUart.put(0)\nUart.put(0)\nfor auto i = 0; i &lt; ConsoleProtocol.SOT_COUNT; i++\nUart.put(ConsoleProtocol.SOT_BYTE)\nend\nUart.flush()\nend\ndef em$halt()\nUart.put(ConsoleProtocol.EOT_BYTE)\nCommon.GlobalInterrupts.disable()\nLed.on()\nCommon.Mcu.shutdown()\nend\ndef em$fail()\nCommon.Mcu.shutdown()\nCommon.GlobalInterrupts.disable()\nwhile true\nblink(2, blinkRate)\nfor auto i = 0; i &lt; 800; i++\nCommon.BusyWait.wait(100)\nend\nend\nend\ndef blink(times, usecs)\nauto k = (times * 2)\nwhile --k\nLed.toggle()\nCommon.BusyWait.wait(usecs)    \nend\nLed.toggle()\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BoardDriverI/","title":"BoardDriverI","text":""},{"location":"cargo/em.core/em.utils/BoardDriverI/#unit-boarddriveri","title":"unit BoardDriverI","text":"em.utils/BoardDriverI.em<pre><code>package em.utils\ninterface BoardDriverI\nhost function bindParamsH(p: ptr_t)\ntemplate genImpl(dn: string)\ntemplate genSpec(dn: string)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BoardDriversGenT/","title":"BoardDriversGenT","text":""},{"location":"cargo/em.core/em.utils/BoardDriversGenT/#unit-boarddriversgent","title":"unit BoardDriversGenT","text":"em.utils/BoardDriversGenT.em<pre><code>package em.utils\nimport BoardInfo\ntemplate BoardDriversGenT\nconfig driversPkg: string\nend\ndef em$generateUnit(pn, un)\nauto brdRec = BoardInfo.readRecordH()\nauto drvPkg = driversPkg\n            |-&gt;package `pn`\n            |-&gt; \nfor dd in brdRec.drvDescs\n            |-&gt;from `drvPkg` import `dd.driver` as `dd.name`\nend\n            |-&gt;\n            |-&gt;module `un`\n            |-&gt; \n            |-&gt;end\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BoardInfo/","title":"BoardInfo","text":""},{"location":"cargo/em.core/em.utils/BoardInfo/#unit-boardinfo","title":"unit BoardInfo","text":"em.utils/BoardInfo.em<pre><code>package em.utils\nfrom em$distro import BoardMeta as Meta\nhost module BoardInfo\nconst PROP_BOARD_CHAIN: string = \"em.lang.BoardChain_\"\nconst PROP_BOARD_KIND: string = \"em.lang.BoardKind\"\ntype PinMap: Meta.PinMap\ntype DrvDesc: Meta.DrvDesc\ntype Record: Meta.Record\nfunction getKind(): string\nfunction readRecordH(): Record&amp;\nprivate:\nfunction cacheGet(kind: string): Record&amp;\nfunction cacheSet(kind: string, rec: Record&amp;)\nfunction collapse(kind: string, db: ptr_t, set: ptr_t): ptr_t\nfunction init()\nfunction mergeBrd(baseBrd: ptr_t, extBrd: ptr_t)\nfunction mergeDb(baseDb: ptr_t, extDb: ptr_t)\nconfig baseFileLoc: string\nconfig localFileLoc: string\nconfig attrs: string[]\nconfig pins: string[]\nconfig boardKind: string\nvar initFlg: bool\nvar recCache: ptr_t\nend\ndef cacheGet(kind)\n^^if (!BoardInfo.recCache) BoardInfo.recCache = {}^^\nreturn ^^BoardInfo.recCache[kind]^^\nend\ndef cacheSet(kind, rec)\n^^BoardInfo.recCache[kind] = rec^^\nend\ndef collapse(kind, db, set)\nreturn ^^db.$DEFAULTS^^ if ^^!kind || kind == '$DEFAULTS'^^\nvar ext: ptr_t = ^^db[kind]^^\nif !ext\nprintf \"*** unknown board kind: '%s'\\n\", kind\nfail\nend\nif ^^set.has(kind)^^\nprintf \"*** circular inheritance chain: '%s'\\n\", kind\nfail\nend\n^^set.add(kind)^^\nvar base: ptr_t = collapse(^^ext.$inherits^^, db, set)\nmergeBrd(base, ext)\nreturn base\nend\ndef getKind()\ninit()\nreturn boardKind\nend\ndef init()\nreturn if initFlg\ninitFlg = true\nattrs = Meta.attrNames\npins = Meta.pinNames\nbaseFileLoc = Meta.baseFileLoc\nauto path = ^^$Path.join(em$session.getRootDir(), 'em-boards-local')^^\nlocalFileLoc = ^^$Fs.existsSync(path) ? path : null^^\nboardKind = ^^em$props.get^^(PROP_BOARD_KIND)\nend\ndef mergeBrd(baseBrd, extBrd)\n^^var aTab = []^^\n^^for (a in extBrd) { aTab[a] = true; aTab.push(a) }^^\nfor a in attrs\n^^baseBrd[a] = extBrd[a]^^ if ^^a in extBrd^^\n^^aTab[a] = false^^\nend\nfor i: uint8 = 0; i &lt; ^^aTab.length^^; i++\nvar an: string = ^^aTab[i]^^\nif an != \"pins\" &amp;&amp; an != \"drvDescs\" &amp;&amp; an != \"nvsFiles\" &amp;&amp; ^^aTab[an]^^\nprintf \"*** unknown attribute name: %s\\n\", an\nfail\nend\nend\n#\n^^var pTab = []^^\n^^for (p in extBrd.pins) { pTab[p] = true; pTab.push(p) }^^\n^^baseBrd.pins = {}^^ if ^^!baseBrd.pins^^\nfor p in pins\n^^baseBrd.pins[p] = extBrd.pins[p]^^ if ^^extBrd.pins &amp;&amp; p in extBrd.pins^^\n^^pTab[p] = false^^\nend\nfor i: uint8 = 0; i &lt; ^^pTab.length^^; i++\nvar pn: string = ^^pTab[i]^^\ncontinue if ^^pn[0] == '$'^^\nif ^^pTab[pn]^^\nprintf \"*** unknown pin name: %s\\n\", pn\nfail\nend\nend\n#\n^^baseBrd.drvDescs = extBrd.drvDescs^^ if ^^extBrd.drvDescs^^\n^^baseBrd.nvsFiles = extBrd.nvsFiles^^ if ^^extBrd.nvsFiles^^\nend\ndef mergeDb(baseDb, extDb)\n^^var brdSet = {}^^\n^^var brdArr = []^^\n^^for (b in baseDb) brdSet[b] = true^^\n^^for (b in extDb) brdSet[b] = true^^\n^^for (b in brdSet) brdArr.push(b)^^\nfor i: uint8 = 0; i &lt; ^^brdArr.length^^; i++\n^^var brdKind = brdArr[i]^^\n^^var baseBrd = baseDb[brdKind]^^\n^^var extBrd = extDb[brdKind]^^\nif ^baseBrd &amp;&amp; ^extBrd\nif ^^extBrd.$overrides^^\nmergeBrd(^baseBrd, ^extBrd)\nelse\nprintf \"*** missing '$overrides' for %s\\n\", ^brdKind\nfail\nend\nelif ^extBrd\nif ^^extBrd.$overrides^^\nprintf \"*** no platform definition for '$overrides' for %s\\n\", ^brdKind\nfail\nelse\n^^baseDb[brdKind] = extDb[brdKind]^^\nend\nend\nend\nend\ndef readRecordH()\ninit()\nif boardKind == null\nprintf \"*** null board kind\\n\"\nfail\nend\nvar rec: Record&amp; = cacheGet(boardKind)\nreturn rec if rec\nvar baseLoc: string = ^em$find(baseFileLoc)\nvar baseDb: ptr_t = ^^$Yaml.load($Fs.readFileSync(baseLoc), 'utf-8')^^\nif localFileLoc != null\nvar localDb: ptr_t = ^^$Yaml.load($Fs.readFileSync(localFileLoc), 'utf-8')^^\nmergeDb(baseDb, localDb)                    \nend\nvar set: ptr_t = ^^new Set^^\nvar base: ptr_t = collapse(boardKind, baseDb, set)\nvar chain: ptr_t = ^^Array.from(set.values()).join('--')^^\n^^em$props.set^^(PROP_BOARD_CHAIN, chain)\nrec = new &lt;Record&gt;\nrec.pinMap = new &lt;PinMap&gt;\nfor a in attrs\n^^rec[a] = base[a]^^\nend\nfor p in pins\n^^rec.pinMap[p] = base.pins[p]^^\nend\n^^for (n in base.drvDescs) {^^\n^^var o = base.drvDescs[n]^^\nrec.drvDescs[rec.drvDescs.length++] = new &lt;DrvDesc&gt; {\nname: ^n, driver: ^^o.driver^^, params: ^^o.params^^\n        }\n^^}^^\ncacheSet(boardKind, rec)\nreturn rec\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BoardMeta/","title":"BoardMeta","text":""},{"location":"cargo/em.core/em.utils/BoardMeta/#unit-boardmeta","title":"unit BoardMeta","text":"em.utils/BoardMeta.em<pre><code>package em.utils\nhost module BoardMeta\ntype PinMap: struct\npin: int8\nend\ntype DrvDesc: struct\nname: string\ndriver: string\nparams: ptr_t\nend        type Record: struct\nattr: bool\npinMap: PinMap&amp;\ndrvDescs: DrvDesc&amp;[]\nend\nconfig baseFileLoc: string = \"biz.biosbob.distro.axm0f343/em-boards\"\nconfig attrNames: string[] = [\n\"$inherits\",\n\"$overrides\",\n\"attr\",\n    ]\nconfig pinNames: string[] = [\n\"pin\",\n    ] \nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Bootup/","title":"Bootup","text":""},{"location":"cargo/em.core/em.utils/Bootup/#unit-bootup","title":"unit Bootup","text":"em.utils/Bootup.em<pre><code>package em.utils\nmodule Bootup\ntype Fxn: function()\nhost function addFxnH(fxn: Fxn)\nfunction exec()\nprivate:\nconfig FXNTAB: Fxn volatile[]\nconfig fxnCnt: uint8\nend\ndef em$construct()\nFXNTABootMemory = true\nend\ndef addFxnH(fxn)\nFXNTAB[fxnCnt++] = fxn\nend\ndef exec()\nfor auto i = 0; i &lt; fxnCnt; i++\nFXNTAB[i]()\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/BufPrint/","title":"BufPrint","text":""},{"location":"cargo/em.core/em.utils/BufPrint/#unit-bufprint","title":"unit BufPrint","text":"em.utils/BufPrint.em<pre><code>package em.utils\nmodule BufPrint\nconfig enabled: bool\nfunction bswap(ptr: ptr_t, cnt: uint16, lab: string = null)\nfunction bytes(ptr: ptr_t, cnt: uint16, lab: string = null)\nfunction words(ptr: ptr_t, cnt: uint16, lab: string = null)\nprivate:\nfunction label(lab: string)\nend\ndef bswap(ptr, cnt, lab)\nif enabled\nlabel(lab) if lab\nprintf \"[\"\nauto pb = &lt;uint8*&gt;ptr\nauto wc = ((cnt + 0x3) &amp; ~0x3) / 4\nauto sep = \"\"\nwhile wc--\nprintf \"%s\", sep\nsep = \", \"\nvar buf: uint8[4]\nbuf[0] = *pb++\nbuf[1] = *pb++\nbuf[2] = *pb++\nbuf[3] = *pb++\nauto nb = cnt &gt;= 4 ? 4 : cnt\ncnt -= nb\nauto idx = 3\nwhile nb--\nprintf \"%02x\", buf[idx--]\nend\nend\nprintf \"]\\n\"\nend\nend\ndef bytes(ptr, cnt, lab)\nif enabled\nlabel(lab) if lab\nauto pb = &lt;uint8*&gt;ptr\nwhile cnt--\nprintf \"%02x\", *pb++\nend\nprintf \"\\n\"\nend\nend\ndef label(lab)\nprintf \"%s = \", lab\nend\ndef words(ptr, cnt, lab)\nif enabled\nlabel(lab) if lab\nprintf \"[\"\nauto pw = &lt;uint32*&gt;ptr\nauto sep = \"\"\nwhile cnt--\nprintf \"%s%08x\", sep, *pw++\nsep = \", \"\nend\nprintf \"]\\n\"\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/ButtonT/","title":"ButtonT","text":""},{"location":"cargo/em.core/em.utils/ButtonT/#unit-buttont","title":"unit ButtonT","text":"em.utils/ButtonT.em<pre><code>package em.utils\ntemplate ButtonT\nend\ndef em$generateUnit(pn, un)\n|-&gt;&gt;&gt;\n    ## ---- generated by em.utils/ButtonT ---- ##\n    package `pn`\n    from em.hal import ButtonI\n    from em.hal import GpioEdgeDetectMinI\n    from em.mcu import Poller\n    from em.utils import FiberMgr\n    module `un`: ButtonI\n        #   ^| implements the ButtonI interface\n        proxy Edge: GpioEdgeDetectMinI\n        #   ^| a GPIO with edge-detection capabilities\n    private:\n        function buttonHandler: Edge.Handler\n        function debounceFB: FiberMgr.FiberBodyFxn\n        config debounceF: FiberMgr.Fiber&amp;\n        var curDuration: uint16\n        var curCb: OnPressedCB\n        var maxDur: uint16\n        var minDur: uint16\n    end\n    def em$construct()\n        Edge.setDetectHandlerH(buttonHandler)\n        debounceF = FiberMgr.createH(debounceFB)\n    end \n    def em$startup()\n        Edge.makeInput()\n        Edge.setInternalPullup(true)\n        Edge.setDetectFallingEdge()\n    end\n    def buttonHandler()\n        Edge.clearDetect()\n        debounceF.post() if curCb\n    end\n    def debounceFB(arg)\n        curDuration = 0\n        for ;;\n            Poller.pause(minDur)\n            return if curDuration == 0 &amp;&amp; !isPressed()\n            curDuration += minDur\n            break if !isPressed() || curDuration &gt;= maxDur\n        end\n        curCb()\n    end\n    def isPressed()\n        return !Edge.get()\n    end\n    def onPressed(cb, minDurationMs, maxDurationMs)\n        curCb = cb\n        maxDur = maxDurationMs\n        minDur = minDurationMs\n        if cb == null\n            Edge.disableDetect()\n        else\n            Edge.enableDetect()\n        end\n    end\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Checksum/","title":"Checksum","text":""},{"location":"cargo/em.core/em.utils/Checksum/#unit-checksum","title":"unit Checksum","text":"em.utils/Checksum.em<pre><code>package em.utils\n# Fletcher-16 checksum\nmodule Checksum\ntype Obj: opaque\nfunction addData(buf: uint8*, len: uint16)\nfunction clear()\nfunction getSum8(): uint8\nfunction getSum16(): uint16\nend\nprivate:\ndef opaque Obj\nsum1: uint16\nsum2: uint16\nend\nend\ndef Obj.addData(ptr, len)\nauto tl = &lt;uint8&gt;0\nwhile len\ntl = len &gt;= 20 ? 20 : len\nlen -= tl\nfor ;;\nthis.sum2 += this.sum1 += *ptr++\ntl -= 1\nbreak if tl == 0\nend\nthis.sum1 = (this.sum1 &amp; 0xFF) + (this.sum1 &gt;&gt; 8)\nthis.sum2 = (this.sum2 &amp; 0xFF) + (this.sum2 &gt;&gt; 8)\nend\nthis.sum1 = (this.sum1 &amp; 0xFF) + (this.sum1 &gt;&gt; 8)\nthis.sum2 = (this.sum2 &amp; 0xFF) + (this.sum2 &gt;&gt; 8)\n#/*\n    for i: uint16 = 0; i &lt; len; i++\n        this.sum1 += *ptr++\n        this.sum1 -= 255 if this.sum1 &gt;= 255;\n        this.sum2 += this.sum1;\n        this.sum2 -= 255 if this.sum2 &gt;= 255;\n    end\n#*/    end\ndef Obj.clear()\nthis.sum1 = this.sum2 = 0xFF\nend\ndef Obj.getSum8()\nreturn &lt;uint8&gt;(this.sum1 ^ this.sum2)\nend\ndef Obj.getSum16()\nreturn this.sum2 &lt;&lt; 8 | this.sum1\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/ConsoleProtocol/","title":"ConsoleProtocol","text":""},{"location":"cargo/em.core/em.utils/ConsoleProtocol/#unit-consoleprotocol","title":"unit ConsoleProtocol","text":"em.utils/ConsoleProtocol.em<pre><code>package em.utils\nmodule ConsoleProtocol\nconst SOT_BYTE: uint8 = 0x3\nconst SOT_COUNT: uint8 = 13\nconst EOT_BYTE: uint8 = 0x4\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Copier/","title":"Copier","text":""},{"location":"cargo/em.core/em.utils/Copier/#unit-copier","title":"unit Copier","text":"em.utils/Copier.em<pre><code>package em.utils\nfrom em.hal import CopierI\nmodule Copier: CopierI\nend\ndef exec(dst, src, cnt)\n^memcpy(dst, src, cnt)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Crc16/","title":"Crc16","text":""},{"location":"cargo/em.core/em.utils/Crc16/#unit-crc16","title":"unit Crc16","text":"em.utils/Crc16.em<pre><code>package em.utils\nmodule Crc16\ntype Obj: opaque\nfunction addByte(b: uint8): uint8\nfunction addData(src: uint8*, len: uint8)\nfunction getSum(): uint16\nfunction getSumLsb(): uint8\nfunction getSumMsb(): uint8\nfunction init()\nend\nhost function createH(): Obj&amp;\nprivate:\nconst POLY: uint16 = 0x8005\ndef opaque Obj\nsum: uint16\nfunction update(b: uint8)\nend\nend\ndef createH()\nreturn new&lt;Obj&gt;\nend\ndef Obj.addByte(b)\nthis.update(b)\nreturn b\nend\ndef Obj.addData(src, len)\nwhile len--\nthis.update(*src++)\nend\nend\ndef Obj.getSum()\nreturn this.sum\nend\ndef Obj.getSumLsb()\nreturn &lt;uint8&gt;(this.sum &amp; 0xFF)\nend\ndef Obj.getSumMsb()\nreturn &lt;uint8&gt;(this.sum &gt;&gt; 8)\nend\ndef Obj.init()\nthis.sum = 0xFFFF\nend\ndef Obj.update(b)\nauto tot = this.sum\nfor auto i = 0; i &lt; 8; i++\nif ((tot &amp; 0x8000) &gt;&gt; 8) ^ (b &amp; 0x80)\ntot = (tot &lt;&lt; 1) ^ POLY\nelse\ntot = (tot &lt;&lt; 1)\nend\nb &lt;&lt;= 1\nend\nthis.sum = tot\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/DebugPinAux/","title":"DebugPinAux","text":""},{"location":"cargo/em.core/em.utils/DebugPinAux/#unit-debugpinaux","title":"unit DebugPinAux","text":"em.utils/DebugPinAux.em<pre><code>package em.utils\nfrom em.mcu import Common\nmodule DebugPinAux\ntype ToggleFxn: function()\nconfig pulseDelay: int32 = -1\nfunction pulse(toggleFxn: ToggleFxn)\nfunction mark(toggleFxn: ToggleFxn, k: uint8)\nprivate:\nfunction delay()\nend\ndef delay()\n## TODO -- finer granularity\nCommon.BusyWait.wait(&lt;uint32&gt;(-pulseDelay))\nend\ndef pulse(toggleFxn)\ntoggleFxn()\ndelay()\ntoggleFxn()\ndelay()\nend\ndef mark(toggleFxn, k)\nwhile k--\npulse(toggleFxn)\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/DebugPinT/","title":"DebugPinT","text":""},{"location":"cargo/em.core/em.utils/DebugPinT/#unit-debugpint","title":"unit DebugPinT","text":"em.utils/DebugPinT.em<pre><code>package em.utils\ntemplate DebugPinT\nend\ndef em$generateUnit(pn, un)\n|-&gt;&gt;&gt;\npackage `pn`\nfrom em.utils import DebugPinAux as Aux\nfrom em.lang import DebugPinI\nfrom em.hal import GpioI\nmodule `un`: DebugPinI\n    proxy Pin: GpioI\nend\ndef clear()\n    Pin.set()\nend\ndef get()\n    return Pin.get() != 0\nend\ndef set()\n    Pin.clear()\nend\ndef toggle()\n    Pin.toggle()\nend\ndef pulse()\n    Aux.pulse(&lt;Aux.ToggleFxn&gt;toggle)\nend\ndef mark(k)\n    Aux.mark(&lt;Aux.ToggleFxn&gt;toggle, k)\nend\ndef reset()\n    Pin.reset()\nend\ndef startup()\n    Pin.makeOutput()\n    Pin.set()\nend\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/EpochTime/","title":"EpochTime","text":""},{"location":"cargo/em.core/em.utils/EpochTime/#unit-epochtime","title":"unit EpochTime","text":"em.utils/EpochTime.em<pre><code>package em.utils\nfrom em.hal import UptimerI\nmodule EpochTime\nproxy Uptimer: UptimerI\ntype UpdateFxn: function(esecs: uint32, esubs: uint32)\nhost function bindUpdateFxnH(fxn: UpdateFxn)\nfunction getCurrent(oSubs: uint32* = null): uint32\nfunction getRaw(oSubs: uint32* = null): uint32\nfunction mkSecs256(secs: uint32, subs: uint32): uint32\nfunction setCurrent(eSecs: uint32, eSubs: uint32 = 0, syncFlag: bool = false)\nprivate:\nconfig updateFxn: UpdateFxn\nvar deltaSecs: uint32\nvar deltaSubs: uint32\nvar lastSecs256: uint32\nvar lastTicks: uint32\nfunction compute(time: Uptimer.Time&amp;, oSubs: uint32*): uint32\nend\ndef bindUpdateFxnH(fxn)\nupdateFxn = fxn\nend\ndef compute(time, oSubs)\nauto eSubs = time.subs + deltaSubs\nauto inc = eSubs &lt; time.subs ? 1 : 0\n    (*oSubs) = eSubs if oSubs\nreturn time.secs + deltaSecs + inc\nend\ndef getCurrent(oSubs)\nreturn compute(Uptimer.read(), oSubs)\nend\ndef getRaw(oSubs)\nauto time = Uptimer.read()\n    *oSubs = time.subs if oSubs\nreturn time.secs\nend\ndef mkSecs256(secs, subs)\nreturn (secs &lt;&lt; 8) | (subs &gt;&gt; 24)\nend\ndef setCurrent(eSecs, eSubs, syncFlag)\nauto time = Uptimer.read()\ndeltaSubs = eSubs - time.subs\nauto dec = deltaSubs &gt; eSubs ? 1 : 0\ndeltaSecs = eSecs - time.secs - dec\nauto eSecs256 = mkSecs256(eSecs, eSubs)\nif syncFlag\nUptimer.calibrate(eSecs256 - lastSecs256, time.ticks - lastTicks) if lastSecs256\nlastSecs256 = eSecs256\nlastTicks = time.ticks\nelse\nlastSecs256 = lastTicks = 0\nend\nvar subs: uint32\nauto secs = compute(time, &amp;subs)\nupdateFxn(eSecs, eSubs) if updateFxn\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Error/","title":"Error","text":""},{"location":"cargo/em.core/em.utils/Error/#unit-error","title":"unit Error","text":"em.utils/Error.em<pre><code>package em.utils\nimport Logger\nmodule Error\ntype Kind: enum\nAPPLICATION, ASSERTION, EXCEPTION, EXPIRATION, WATCHDOG\nend\ntype RaiseFxn: function (kind: Kind, infoA: iarg_t, infoB: iarg_t)\nhost function bindOnRaiseH(fxn: RaiseFxn)\nfunction raise: RaiseFxn\nprivate:\nconfig KIND_ATOM: atom_t[] = [\n        @\"APPLICATION\", @\"ASSERTION\", @\"EXCEPTION\", @\"EXPIRATION\", @\"WATCHDOG\"\n    ]\nconfig errorE: Logger.EventKind&amp;\nconfig onRaiseFxn: RaiseFxn\nend\ndef em$construct()\n## TODO -- atomize error kind\nerrorE = Logger.declareEventH(\"ERROR: $a [0x%08x, 0x%08x]\", \"*--*\")\nend\ndef bindOnRaiseH(fxn)\nonRaiseFxn = fxn\nend\ndef raise(kind, infoA, infoB)\nerrorE.log(&lt;addr_t&gt;KIND_ATOM[&lt;uint8&gt;kind], &lt;addr_t&gt;infoA, &lt;addr_t&gt;infoB)\nonRaiseFxn(kind, infoA, infoB) if onRaiseFxn\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/FftC32/","title":"FftC32","text":""},{"location":"cargo/em.core/em.utils/FftC32/#unit-fftc32","title":"unit FftC32","text":"em.utils/FftC32.em<pre><code>package em.utils\nfrom em.lang import Math\nmodule FftC32\ntype Complex: class\nre: int16\nim: int16\nfunction get(): uint32\nfunction set(w: uint32)\nend\nconfig fftSize: uint16 = 128\nconfig shift: uint8 = 1\nfunction exec(buf: Complex[])\nprivate:\nconfig N_WAVE: uint16\nconfig N_WAVE_LOG2: uint8\nconfig SINE_WAVE: int16[]\nfunction fixMul(a: int16, b: int16): int16\nend\ndef em$construct()\nN_WAVE = fftSize\nN_WAVE_LOG2 = Math.log2(N_WAVE)\nauto numHalf = N_WAVE / 2\nauto numQtr = N_WAVE / 4\nSINE_WAVE.length = N_WAVE - numQtr\nauto rng = Math.PI / 2\nfor auto i = 0; i &lt; SINE_WAVE.length; i++\nif i &lt;= numQtr\nauto sx = Math.sin((rng / numQtr) * i)\nSINE_WAVE[i] = Math.round(sx * 32767) &gt;&gt; shift\nelif i &lt; numHalf\nSINE_WAVE[i] = SINE_WAVE[numHalf - i]\nelse\nSINE_WAVE[i] = -(SINE_WAVE[i - numHalf])\nend\nend\nend\ndef exec(buf)\nauto mr = 0\nfor auto m = 1; m &lt; fftSize; m++\nauto l = fftSize\nfor ;;\nl &gt;&gt;= 1\ncontinue if mr + l &gt; fftSize - 1\nbreak\nend\nmr = (mr &amp; (l - 1)) + l\ncontinue if mr &lt;= m\nauto t = buf[m].get()\nbuf[m].set(buf[mr].get())\nbuf[mr].set(t)\nend\nauto stage = 1\nauto sineStep = N_WAVE_LOG2 - 1\nwhile stage &lt; fftSize\nauto twiddleStep = stage &lt;&lt; 1\nfor auto grp = 0; grp &lt; stage; grp++\nauto idx = grp &lt;&lt; sineStep\nauto wr = SINE_WAVE[idx + N_WAVE / 4]\nauto wi = -SINE_WAVE[idx]\nfor auto i = grp; i &lt; fftSize; i += twiddleStep\nauto j = i + stage\nauto fci = &amp;buf[i]\nauto fcj = &amp;buf[j]\nauto tr = fixMul(wr, fcj.re) - fixMul(wi, fcj.im)\nauto ti = fixMul(wr, fcj.im) + fixMul(wi, fcj.re)\nauto qr = fci.re &gt;&gt; shift\nauto qi = fci.im &gt;&gt; shift\nfcj.re = qr - tr\nfcj.im = qi - ti\nfci.re = qr + tr\nfci.im = qi + ti\nend\nend\nsineStep -= 1\nstage = twiddleStep\nend\nend\ndef fixMul(a, b)\nauto c = (&lt;int32&gt;a * &lt;int32&gt;b) &gt;&gt; 14\nb = &lt;int16&gt;(&lt;uint32&gt;c &amp; 0x01)\na = &lt;int16&gt;((c &gt;&gt; 1) + b)\nreturn a\nend\ndef Complex.get()\nreturn *(&lt;uint32*&gt;this)\nend\ndef Complex.set(w)\n    *(&lt;uint32*&gt;this) = w\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/FftQ15/","title":"FftQ15","text":""},{"location":"cargo/em.core/em.utils/FftQ15/#unit-fftq15","title":"unit FftQ15","text":"em.utils/FftQ15.em<pre><code>package em.utils\nfrom em.lang import Math\nmodule FftQ15\nconfig fftSize: uint16 = 128\nconfig shift: uint8 = 1\nfunction exec(fr: int16[], fi: int16[])\nprivate:\nconfig N_WAVE: uint16\nconfig N_WAVE_LOG2: uint8\nconfig SINE_WAVE: int16[]\nfunction fixMul(a: int16, b: int16): int16\nend\ndef em$construct()\nN_WAVE = fftSize\nN_WAVE_LOG2 = Math.log2(N_WAVE)\nauto numHalf = N_WAVE / 2\nauto numQtr = N_WAVE / 4\nSINE_WAVE.length = N_WAVE - numQtr\nauto rng = Math.PI / 2\nfor auto i = 0; i &lt; SINE_WAVE.length; i++\nif i &lt;= numQtr\nauto sx = Math.sin((rng / numQtr) * i)\nSINE_WAVE[i] = Math.round(sx * 32767) &gt;&gt; shift\nelif i &lt; numHalf\nSINE_WAVE[i] = SINE_WAVE[numHalf - i]\nelse\nSINE_WAVE[i] = -(SINE_WAVE[i - numHalf])\nend\nend\nend\ndef exec(fr, fi)\nauto mr = 0\nfor auto m = 1; m &lt; fftSize; m++\nauto l = fftSize\nfor ;;\nl &gt;&gt;= 1\ncontinue if mr + l &gt; fftSize - 1\nbreak\nend\nmr = (mr &amp; (l - 1)) + l\ncontinue if mr &lt;= m\nauto tr = fr[m]\nfr[m] = fr[mr]\nfr[mr] = tr\nauto ti = fi[m]\nfi[m] = fi[mr]\nfi[mr] = ti\nend\nauto stage = 1\nauto sineStep = N_WAVE_LOG2 - 1\nwhile stage &lt; fftSize\nauto twiddleStep = stage &lt;&lt; 1\nfor auto grp = 0; grp &lt; stage; grp++\nauto idx = grp &lt;&lt; sineStep\nauto wr = SINE_WAVE[idx + N_WAVE / 4]\nauto wi = -SINE_WAVE[idx]\nfor auto i = grp; i &lt; fftSize; i += twiddleStep\nauto j = i + stage\nauto tr = fixMul(wr, fr[j]) - fixMul(wi, fi[j])\nauto ti = fixMul(wr, fi[j]) + fixMul(wi, fr[j])\nauto qr = fr[i] &gt;&gt; shift\nauto qi = fi[i] &gt;&gt; shift\nfr[j] = qr - tr\nfi[j] = qi - ti\nfr[i] = qr + tr\nfi[i] = qi + ti\nend\nend\nsineStep -= 1\nstage = twiddleStep\nend\nend\ndef fixMul(a, b)\nauto c = (&lt;int32&gt;a * &lt;int32&gt;b) &gt;&gt; 14\nb = &lt;int16&gt;(&lt;uint32&gt;c &amp; 0x01)\na = &lt;int16&gt;((c &gt;&gt; 1) + b)\nreturn a\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/FiberMgr/","title":"FiberMgr","text":""},{"location":"cargo/em.core/em.utils/FiberMgr/#unit-fibermgr","title":"unit FiberMgr","text":"em.utils/FiberMgr.em<pre><code>package em.utils\nfrom em.mcu import Common\nfrom em.utils import ListMgr\nmodule FiberMgr\n#   ^| manages opaque fiber objects\ntype FiberBodyFxn: function(arg: uarg_t)\n#   ^| function signature of fiber body\ntype Fiber: opaque\n#   ^| opaque fiber object - public specification\nhost function initH(fxn: FiberBodyFxn, arg: uarg_t = 0)\n#   ^| initialize this fiber and bind its function and argument\nfunction getArg(): uarg_t\n#   ^| get this fiber's body function argument\nfunction getFxn(): FiberBodyFxn\n#   ^| get this fiber's body function\nfunction post()\n#   ^| make this fiber ready-to-run\nfunction setArg(a: uarg_t)\n#   ^| set this fiber's body function argument\nfunction setFxn(f: FiberBodyFxn)\n#   ^| set this fiber's body function\nend\nhost function createH(fxn: FiberBodyFxn, arg: uarg_t = 0): Fiber&amp;\n#   ^| allocate and initialize a fiber; see Fiber.initH\nfunction run()\n#   ^| initiate dispatch of ready-to-run fibers\nprivate:\ndef opaque Fiber\nelem: ListMgr.Element\nfxn_: FiberBodyFxn\narg_: uarg_t\nend\nfunction dispatch()\nvar fiberTab: Fiber[]\nvar readyList: ListMgr.List\nend\ndef em$construct() \nreadyList.initH()\nend\ndef createH(fxn, arg)\nvar fiber: Fiber&amp; = fiberTab[fiberTab.length++]\nfiber.initH(fxn, arg)\nreturn fiber\nend\ndef dispatch()\nfor ;;\nbreak if readyList.hasElements() == 0\nauto fiber = &lt;Fiber&amp;&gt;readyList.get()\nCommon.GlobalInterrupts.enable()\nauto fxn = fiber.fxn_\nfxn(fiber.arg_)\nCommon.GlobalInterrupts.disable()\nend   end\ndef run()\nCommon.Idle.wakeup()\nCommon.GlobalInterrupts.enable()\nfor ;;\nCommon.GlobalInterrupts.disable()\ndispatch()\nCommon.Idle.exec()\nend\nend\ndef Fiber.initH(fxn, arg)\nthis.elem.initH()\nthis.fxn_ = fxn\nthis.arg_ = arg\nend\ndef Fiber.post()\nauto key = Common.GlobalInterrupts.disable()\nreadyList.add(this.elem) if !this.elem.isActive()\nCommon.GlobalInterrupts.restore(key)\nend\ndef Fiber.getArg()\nreturn this.arg_\nend\ndef Fiber.setArg(a)\nthis.arg_ = a\nend\ndef Fiber.setFxn(f)\nthis.fxn_ = f\nend\ndef Fiber.getFxn()\nreturn this.fxn_\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Formatter/","title":"Formatter","text":""},{"location":"cargo/em.core/em.utils/Formatter/#unit-formatter","title":"unit Formatter","text":"em.utils/Formatter.em<pre><code>package em.utils\nfrom em.lang import Console\nmodule Formatter\nfunction print(fmt: string, a1: iarg_t = 0, a2: iarg_t = 0, a3: iarg_t = 0, a4: iarg_t = 0, a5: iarg_t = 0, a6: iarg_t = 0)\nfunction puts(s: string)\nprivate:\nconst OUTMAX: uint8 = ((32 + 2) / 3) + 5\nfunction c2d(c: char): uint8\nfunction formatNum(buf: char*, num: uint32, base: uint8, pad: char, len: uint8): char*\nfunction isDigit(c: char): bool\nconfig hexDigs: string = \"0123456789abcdef\"\nend\ndef c2d(c)\nreturn c - '0'\nend\ndef formatNum(buf, num, base, pad, len)\nauto cnt = len\n    *(--buf) = 0\nfor ;;\n        *(--buf) = hexDigs[&lt;uint8&gt; (num % base)]\nnum /= base\nbreak if len &gt; 0 &amp;&amp; --cnt == 0\nbreak if num == 0\nend\nwhile cnt-- &gt; 0\n        *(--buf) = pad\nend\nreturn buf\nend\ndef isDigit(c)\nreturn c &gt;= '0' &amp;&amp; c &lt;= '9'\nend\ndef print(fmt, a1, a2, a3, a4, a5, a6)\nvar ch: char\nvar buf: char[OUTMAX]\nvar args: iarg_t[6]\nvar argp: iarg_t* = &amp;args[0]\nargs[0] = a1\nargs[1] = a2\nargs[2] = a3\nargs[3] = a4\nargs[4] = a5\nargs[5] = a6\nwhile (ch = *fmt++) != 0\nauto pad = ' '\nauto len = 0\nif (ch != '%') \nConsole.wrC(ch)\ncontinue\nend\nch = *fmt++\nif ch == '0'\npad = '0'\nch = *fmt++\nend\nwhile isDigit(ch)\nlen = (len * 10) + c2d(ch)\nch = *fmt++\nend\nvar out: char*\nif ch == 'd'\nvar dn: int32 = &lt;int32&gt; *argp++\nif dn &lt; 0\nConsole.wrC('-')\ndn = -dn\nend\nout = formatNum(&amp;buf[OUTMAX], &lt;uint32&gt; dn, 10, pad, len)\nelif ch == 'x' var xn: uint32 = &lt;uint32&gt; *argp++\nout = formatNum(&amp;buf[OUTMAX], xn, 16, pad, len)\nelif ch == 's'\nout = &lt;char*&gt; *argp++\nelse\nConsole.wrC(ch == 'c' ? &lt;char&gt; *argp++ : ch)\ncontinue\nend\nputs(&lt;string&gt;out)\nend\nend\ndef puts(s)\nvar cp: char* = &lt;char*&gt;s\nvar ch: char\nwhile (ch = *cp++) != 0\nConsole.wrC(ch)\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/FormattingConsole/","title":"FormattingConsole","text":""},{"location":"cargo/em.core/em.utils/FormattingConsole/#unit-formattingconsole","title":"unit FormattingConsole","text":"em.utils/FormattingConsole.em<pre><code>package em.utils\nfrom em.lang import ConsoleProviderI\nfrom em.mcu import ConsoleUart\nimport Formatter\nmodule FormattingConsole: ConsoleProviderI\nend\ndef flush()\nConsoleUart.flush()\nend\ndef print(fmt, a1, a2, a3, a4, a5, a6)\nFormatter.print(fmt, a1, a2, a3, a4, a5, a6)\nend\ndef put(data)\nConsoleUart.put(data)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/HeapMem/","title":"HeapMem","text":""},{"location":"cargo/em.core/em.utils/HeapMem/#unit-heapmem","title":"unit HeapMem","text":"em.utils/HeapMem.em<pre><code>package em.utils\nfrom em.mcu import Common\nfrom em.mcu import Copier\nmodule HeapMem\nconfig baseAddr: addr_t\nconfig maxBytes: uint16\nfunction alloc(size: uint16): ptr_t\nfunction avail(): uint16\nfunction mark()\nfunction release()\nprivate:\nvar curTopPtr: uint32*\nvar savTopPtr: uint32*\nend\ndef em$startup()\nreturn if Common.Mcu.isWarm()\ncurTopPtr = baseAddr\nend\ndef alloc(size)\nauto ptr = curTopPtr\nauto wc = ((size + 3) &amp; ~0x3) / 4\ncurTopPtr += wc\nreturn ptr\nend\ndef avail()\nreturn &lt;uint16&gt;((baseAddr + maxBytes) - &lt;uint32&gt;curTopPtr)\nend\ndef mark()\n    *curTopPtr = &lt;uint32&gt;savTopPtr\nsavTopPtr = curTopPtr++\nend\ndef release()\nfail if !savTopPtr\ncurTopPtr = savTopPtr\nsavTopPtr = &lt;uint32*&gt;*curTopPtr\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/HeapStatic/","title":"HeapStatic","text":""},{"location":"cargo/em.core/em.utils/HeapStatic/#unit-heapstatic","title":"unit HeapStatic","text":"em.utils/HeapStatic.em<pre><code>package em.utils\nfrom em.mcu import Common\nmodule HeapStatic\nconfig baseAddr: addr_t\nconfig maxBytes: uint16\nhost function allocH(size: uint16): ptr_t\nfunction getTopAddr(): addr_t\nhost function getTopAddrH(): addr_t\nprivate:\nconst MASK: uint32 = 0x3\nconfig topAddr: addr_t\nend\ndef em$construct()\nreturn if baseAddr || maxBytes == 0\nprintf \"*** HeapStatic:  baseAddr == 0\\n\"\nfail\nend\ndef em$startup()\nreturn if Common.Mcu.isWarm()\n^memset(&lt;ptr_t&gt;baseAddr, 0, topAddr - baseAddr) if topAddr &amp;&amp; Common.Mcu.getResetCode() &lt;= Common.Mcu.COLD_RESET\nend\ndef allocH(size)\ntopAddr = baseAddr if topAddr == 0\nauto p = &lt;ptr_t&gt;topAddr\ntopAddr += size\ntopAddr = (topAddr + MASK) &amp; ~MASK\nreturn p if (topAddr - baseAddr) &lt; maxBytes\nprintf \"*** HeapStatic.allocH: maxBytes = %d, size = %d\\n\", maxBytes, size\nfail\nend\ndef getTopAddr()\nreturn topAddr\nend\ndef getTopAddrH()\nreturn topAddr\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/LedBlinkerAux/","title":"LedBlinkerAux","text":""},{"location":"cargo/em.core/em.utils/LedBlinkerAux/#unit-ledblinkeraux","title":"unit LedBlinkerAux","text":"em.utils/LedBlinkerAux.em<pre><code>package em.utils\nfrom em.mcu import Poller\nimport AlarmMgr\nimport ProcMgr\nmodule LedBlinkerAux\ntype LedFxn: function()\nfunction blink(count: uint16, rateSecs: uint16 = 1, rateMs: uint16 = 0)\nfunction setFxns(onFxn: fxn_t, offFxn: fxn_t)\nprivate:\nfunction blinkNext()\nconfig alarm: AlarmMgr.Alarm&amp;\nvar curOnFxn: LedFxn\nvar curOffFxn: LedFxn\nvar count: uint16\nvar rate256: uint32\nvar rateMs: uint32\nend\ndef em$construct()\nalarm = AlarmMgr.createH(ProcMgr.createH(blinkNext))\nend\ndef blink(count, rateSecs, rateMs)\nLedBlinkerAux.count = count\nLedBlinkerAux.rate256 = rateSecs * 256\nLedBlinkerAux.rateMs = rateMs\ncurOffFxn()\nalarm.wakeup(rate256, rateMs) if count\nend\ndef blinkNext()\n###    wink(10, 0)  ## TODO\ncount -= 1\nalarm.wakeup(rate256, rateMs) if count\nend\ndef setFxns(onFxn, offFxn)\ncurOnFxn = onFxn\ncurOffFxn = offFxn\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/LedBlinkerI/","title":"LedBlinkerI","text":""},{"location":"cargo/em.core/em.utils/LedBlinkerI/#unit-ledblinkeri","title":"unit LedBlinkerI","text":"em.utils/LedBlinkerI.em<pre><code>package em.utils\nfrom em.hal import LedI\ninterface LedBlinkerI: LedI\nfunction blink(count: uint16, rateSecs: uint16 = 1, rateMs: uint16 = 0)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/LedBlinkerT/","title":"LedBlinkerT","text":""},{"location":"cargo/em.core/em.utils/LedBlinkerT/#unit-ledblinkert","title":"unit LedBlinkerT","text":"em.utils/LedBlinkerT.em<pre><code>package em.utils\ntemplate LedBlinkerT\nend\ndef em$generateUnit(pn, un)\n|-&gt;&gt;&gt;\npackage `pn`\nfrom em.hal import LedI\nfrom em.utils import LedBlinkerAux\nfrom em.utils import LedBlinkerI\nmodule `un`: LedBlinkerI\n    proxy Led: LedI\nend\ndef isOn()\n    return Led.isOn()\nend\ndef on()\n    Led.on()\nend\ndef off()\n    Led.off()\nend\ndef toggle()\n    Led.toggle()\nend\ndef blink(count, rateSecs, rateMs)\n    LedBlinkerAux.setFxns(Led.on, Led.off)\n    LedBlinkerAux.blink(count, rateSecs, rateMs)\nend\ndef wink(onMs, offMs)\n    LedBlinkerAux.setFxns(Led.on, Led.off)\n    LedBlinkerAux.wink(onMs, offMs)\nend\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/LedT/","title":"LedT","text":""},{"location":"cargo/em.core/em.utils/LedT/#unit-ledt","title":"unit LedT","text":"em.utils/LedT.em<pre><code>package em.utils\ntemplate LedT end\ndef em$generateUnit(pn, un)\n|-&gt;&gt;&gt;\n    package `pn`\n    from em.hal import LedI\n    from em.hal import GpioI\n    from em.mcu import Poller\n    module `un`: LedI\n        proxy Pin: GpioI\n        config activeLow: bool = false\n    end\n    def em$startup()\n        Pin.makeOutput()\n        if activeLow\n            Pin.set()            \n        else \n            Pin.clear()                \n        end\n    end\n    def on()\n        if activeLow\n            Pin.clear()            \n        else \n            Pin.set()                \n        end   \n    end\n    def off()\n        if activeLow\n            Pin.set()            \n        else \n            Pin.clear()                \n        end   \n    end\n    def toggle()\n        Pin.toggle()\n    end\n    def isOn()\n        return activeLow ? !Pin.get() : Pin.get()\n    end\n    def wink(msecs)\n        on()\n        Poller.pause(msecs)\n        off()\n    end          \n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/ListManagerI/","title":"ListManagerI","text":""},{"location":"cargo/em.core/em.utils/ListManagerI/#unit-listmanageri","title":"unit ListManagerI","text":"em.utils/ListManagerI.em<pre><code>package em.utils\n#! Implemented by a List Manager module\n#! Element and List declarations.\ninterface ListManagerI type Element: opaque #! Target and Host function to initialize an Element\nfunction init()\nhost function initH()\n#! Returns non-null if the Element is currently a member of a List\nfunction isActive(): uarg_t\nend\ntype List: opaque #! Target and Host function to initialize a List\nfunction init()\nhost function initH()\n#! Adds an element to the List as defined by the List Manager\nfunction add(elem: Element&amp;)\n#! Returns a reference to an Element and removes it from the List\nfunction get(): ref_t\n#! Returns a reference to the Element at the specified index\nfunction getAt(index: uint8): ref_t\n#! Returns a reference to the next Element from the specified Element\nfunction getNext(elem: Element&amp;): ref_t\n#! Returns a non-zero value if the List is not empty\nfunction hasElements(): uarg_t\n#! Displays information about the List\nfunction print()\n#! Removes the specified Element from the List\nfunction remove(elem: Element&amp;)\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/ListMgr/","title":"ListMgr","text":""},{"location":"cargo/em.core/em.utils/ListMgr/#unit-listmgr","title":"unit ListMgr","text":"em.utils/ListMgr.em<pre><code>package em.utils\nmodule ListMgr\ntype Element: opaque function init()\nhost function initH()\nfunction isActive(): uarg_t\nend\ntype List: opaque function init()\nhost function initH()\nfunction add(elem: Element&amp;)\nfunction get(): ref_t\nfunction getAt(index: uint8): ref_t\nfunction getNext(elem: Element&amp;): ref_t\nfunction hasElements(): uarg_t\nfunction print()\nfunction remove(elem: Element&amp;)\nend\nprivate:\ndef opaque Element next: Element&amp; volatile\nend\ndef opaque List first: Element&amp; volatile\nlast: Element&amp; volatile\nend\nend\ndef Element.init() \nthis.next = null\nend\ndef Element.initH() \nthis.next = null\nend\ndef Element.isActive() \nreturn &lt;uarg_t&gt; this.next\nend\ndef List.init() \nthis.first = this.last = &lt;Element&amp;&gt; &amp;this.first\nend\ndef List.initH() \nthis.first = this.last = &lt;Element&amp;&gt; &amp;this.first;\nend\ndef List.add(elem)\nthis.last.next = elem\nthis.last = elem\nelem.next = &lt;Element&amp;&gt; this\nend\ndef List.get() \nauto elem = this.first\nthis.last = &lt;Element&amp;&gt;this if (this.first = elem.next) == &lt;Element&amp;&gt;this\nelem.next = null\nreturn elem\nend\ndef List.getAt(index)\nauto elem = this.first\nauto i = 0\nif this.hasElements()\nfor ;;\nbreak if i++ == index                elem = elem.next                break if elem == &lt;Element&amp;&gt; this\nend\nelem = null if elem == &lt;Element&amp;&gt; this\nelse elem = null\nend\nreturn elem\nend\ndef List.getNext(elem) \nreturn elem == this.last ? null : elem.next\nend\ndef List.hasElements() \nreturn (&lt;uarg_t&gt; this.first) ^ &lt;uarg_t&gt; this\nend\ndef List.print() \nauto elem = this.first\nauto i = 0\nif this.hasElements()\nfor ;;\nprintf \"elem%d %p\\n\", i++, elem\nelem = elem.next\nbreak if elem == &lt;Element&amp;&gt; this\nend\nelse printf \"list empty\\n\"\nend\nprintf \"\\n\" end\ndef List.remove(elem)\nauto e = this.first\nif this.hasElements()\nif elem == this.first\nthis.first = this.first.next\nelse for ;; \nif e.next == elem\ne.next = elem.next                    break    end break if e == &lt;Element&amp;&gt; this\nend\nend\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/LoaderAuxI/","title":"LoaderAuxI","text":""},{"location":"cargo/em.core/em.utils/LoaderAuxI/#unit-loaderauxi","title":"unit LoaderAuxI","text":"em.utils/LoaderAuxI.em<pre><code>package em.utils\ninterface LoaderAuxI\nfunction jumpTo(codeAddr: addr_t)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/LoaderP/","title":"LoaderP","text":""},{"location":"cargo/em.core/em.utils/LoaderP/#unit-loaderp","title":"unit LoaderP","text":"em.utils/LoaderP.em<pre><code>package em.utils\nfrom em$distro import LoaderC\nfrom LoaderC import Flash\nfrom LoaderC import LoaderAux\nfrom em.build.misc import AppImage\nfrom em.mcu import Common\nmodule LoaderP\nconfig initData: bool\nconfig noWarmCheck: bool\nend\ndef em$reset()\nCommon.Mcu.startup()\nend\ndef em$run()\nauto sz = AppImage.getStagingSize()\nif sz\nauto srcAddr = AppImage.stagingAddr\nauto dstAddr = AppImage.descAddr\nFlash.erase(dstAddr, srcAddr)\nFlash.write(dstAddr, srcAddr, sz)\nFlash.erase(srcAddr, srcAddr + sz)\nend\nauto desc = AppImage.getDesc()\nif noWarmCheck || !Common.Mcu.isWarm()\nauto dst = &lt;uint32*&gt;desc.bssAddr\nauto sz = desc.bssSize\nwhile sz--\n            *dst++ = 0\nend\nauto src = &lt;uint32*&gt;desc.codeLoad\ndst = desc.codeAddr\nsz = &lt;uint32*&gt;desc.bssAddr - dst\nwhile sz--\n            *dst++ = *src++\nend\nif initData\nsrc = desc.dataLoad\ndst = desc.dataAddr\nsz = desc.dataSize\nwhile sz--\n                *dst++ = *src++\nend\nend\nend\nLoaderAux.jumpTo(desc.codeAddr)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/Logger/","title":"Logger","text":""},{"location":"cargo/em.core/em.utils/Logger/#unit-logger","title":"unit Logger","text":"em.utils/Logger.em<pre><code>package em.utils\nfrom em.hal import FlashI\nfrom em.hal import FlashN\nfrom em.lang import Assert\nfrom em.mcu import Common\nfrom em.lang import Console\nimport EpochTime\nimport Formatter\nimport HeapStatic\nmodule Logger\nproxy Flash: FlashI\ntype Accum: opaque\nfunction add(val: uint32 = 0)\nfunction clear()\nfunction getBin(idx: uint8): uint32\nfunction getCount(): uint32\nfunction getMax(): uint32\nfunction print()\nend\ntype EventKind: opaque\nfunction cache(a1: addr_t = 0, a2: addr_t = 0, a3: addr_t = 0)\nfunction log(a1: addr_t = 0, a2: addr_t = 0, a3: addr_t = 0)\nfunction print(a1: addr_t = 0, a2: addr_t = 0, a3: addr_t = 0)\nend\ntype Policy: enum\nNIL, QUIET, PRINT, STORE\nend\nconfig POLICY: Policy = Policy.NIL\nconfig ENTRY_COUNT: uint16 = 16\nconfig STORE_SECTOR: uint8 = 0\nhost function createAccumH(lab: string, grp: string, lims: uint32[] = null): Accum&amp;\nhost function declareEventH(msg: string, grp: string): EventKind&amp;\nfunction flush()\nfunction isEmpty(): bool\nfunction mkTime(): uint32\nfunction print()\nfunction putBytes(bp: uint8*, cnt: uint16)\nfunction putc(b: uint8)\nfunction store()\nprivate:\nconst PKT_CODE: uint8 = 0xFE\nconst EVT_CODE: uint8 = 0xFD\nconst ACC_CODE: uint8 = 0xFC\nconst BEG_CODE: uint8 = 0xFB\nconst END_CODE: uint8 = 0xFA\ntype Group: class\nchars: char[4]\nhost function initH(gs: string)\nend\ndef opaque Accum\ndata: uint32[]\nmetaIdx: uint8\nfunction getMeta(): AccumMeta&amp;\nend\ntype AccumMeta: struct\nlab: string\nlims: uint32[]\nhasMax: bool\nlimCnt: uint8\ngroup: Group\nsize: uint8\nend\ndef opaque EventKind\nmsg: string\nkidx: uint16\ngroup: Group\nend\ntype EventInst: class\ntime: uint32\na1: iarg_t\na2: iarg_t\na3: iarg_t\nkidx: uint16\nfunction put()\nend\ntype Cursor: class\nidx: uint16\nfunction next(): EventInst&amp;\nend\nconfig accMetaTab: AccumMeta[]\nconfig sectBeg: addr_t\nconfig sectEnd: addr_t\nconfig totalAccSize: uint16\nvar accTab: Accum&amp;[..]\nvar evkTab: EventKind&amp;[..]\nvar buf: EventInst[]\nvar curs: Cursor&amp;\nend\ndef em$configure()\nFlash ?= FlashN\nend\ndef em$construct()\nbuf = HeapStatic.allocH(sizeof&lt;EventInst&gt; * ENTRY_COUNT) if POLICY != Policy.NIL\ncurs = HeapStatic.allocH(sizeof&lt;Cursor&gt;) if POLICY != Policy.NIL\nsectBeg = &lt;addr_t&gt;(Flash.getSectorSizeH() * STORE_SECTOR)\nsectEnd = sectBeg + Flash.getSectorSizeH()\nend\ndef createAccumH(lab, grp, lims)\nreturn null if POLICY == Policy.NIL\nauto accMeta = &lt;AccumMeta&amp;&gt;accMetaTab[accMetaTab.length++]\naccMeta.lab = lab\naccMeta.group.initH(grp)\naccMeta.hasMax = (lims != null)\naccMeta.lims = lims if accMeta.hasMax\naccMeta.limCnt = &lt;uint8&gt;lims.length if accMeta.hasMax\naccMeta.size = (1 + (!accMeta.hasMax ? 0 : (1 + accMeta.limCnt))) * sizeof&lt;uint32&gt;\nauto acc = new&lt;Accum&gt;\naccTab[accTab.length++] = acc\nacc.data = HeapStatic.allocH(accMeta.size)\nacc.metaIdx = &lt;uint8&gt;accMetaTab.length\ntotalAccSize += accMeta.size\nreturn acc\nend\ndef declareEventH(msg, grp)\nreturn null if POLICY == Policy.NIL\nauto ek = new&lt;EventKind&gt;\nevkTab[evkTab.length++] = ek\nek.kidx = evkTab.length\nek.msg = &lt;string&gt;msg\nek.group.initH(grp)\nreturn ek\nend\ndef flush()\nprint() if POLICY == Policy.PRINT\nstore() if POLICY == Policy.QUIET || POLICY == Policy.STORE\nend\ndef isEmpty()\nif POLICY != Policy.NIL\nfor acc in accTab\nreturn false if acc.data[0]\nend\nfor auto i = 0; i &lt; ENTRY_COUNT; i++\nreturn false if buf[i].kidx != 0\nend\nend\nreturn true\nend\ndef mkTime()\nvar subs: uint32\nauto secs = EpochTime.getRaw(&amp;subs)\nreturn (secs &lt;&lt; 8) | (subs &gt;&gt; 24)\nend\ndef print()\nif POLICY &gt; Policy.QUIET\nputc(PKT_CODE)\nputc(BEG_CODE)\nfor acc in accTab\nacc.print()\nend\nfor auto i = 0; i &lt; ENTRY_COUNT; i++\nauto evt = curs.next()\ncontinue if evt.kidx == 0\nevt.put()\nend\nputc(PKT_CODE)\nputc(END_CODE)\nend\nend\ndef putBytes(bp, cnt)\nwhile cnt--\nauto b = *bp++\nputc(PKT_CODE) if b == PKT_CODE\nputc(b)\nend\nend\ndef putc(b)\nConsole.Provider.put(b)\nend\ndef store()\nif POLICY != Policy.NIL &amp;&amp; STORE_SECTOR &gt; 0\nauto saddr = sectBeg\nFlash.erase(saddr)\nvar et: uint32 = EpochTime.getCurrent()\nsaddr = Flash.write(saddr, &amp;et, sizeof&lt;uint32&gt;)\nfor acc in accTab\nsaddr = Flash.write(saddr, &amp;acc.data[0], acc.getMeta().size)\nend\nfor auto i = 0; i &lt; ENTRY_COUNT; i++\nauto evt = curs.next()\ncontinue if evt.kidx == 0\nsaddr = Flash.write(saddr, evt, sizeof&lt;EventInst&gt;)\nevt.kidx = 0\nend\nend\nend\ndef Accum.add(val)\nauto accMeta = this.getMeta()\nthis.data[0] += 1\nreturn if !accMeta.hasMax\nthis.data[1] = val if val &gt; this.data[1]\nfor auto i = 0; i &lt; accMeta.limCnt; i++\nthis.data[2 + i] += 1 if val &lt; accMeta.lims[i]\nend\nend\ndef Accum.clear()\nauto accMeta = this.getMeta()\nauto words = accMeta.hasMax ? (2 + accMeta.limCnt) : 1\n^memset(&amp;this.data[0], 0, words * sizeof&lt;uint32&gt;)\nend\ndef Accum.getBin(idx)\nreturn this.data[idx + 2]\nend\ndef Accum.getCount()\nreturn this.data[0]\nend\ndef Accum.getMax()\nreturn this.data[1]\nend\ndef Accum.getMeta()\nreturn &lt;AccumMeta&amp;&gt;(&amp;accMetaTab[this.metaIdx-1])\nend\ndef Accum.print()\nif POLICY &gt; Policy.QUIET\nauto accMeta = this.getMeta()\nputc(PKT_CODE)\nputc(ACC_CODE)\nputc(this.metaIdx)\nputBytes(&lt;uint8*&gt;&amp;this.data[0], accMeta.size)\nend\nend\ndef Cursor.next()\nauto evt = &amp;buf[this.idx++]\nthis.idx = 0 if this.idx &gt;= ENTRY_COUNT\nreturn evt\nend\ndef EventInst.put()\nputc(PKT_CODE)\nputc(EVT_CODE)\nputBytes(&lt;uint8*&gt;this, sizeof&lt;EventInst&gt; - sizeof&lt;uint16&gt;)\nend\ndef EventKind.cache(a1, a2, a3)\nif POLICY != Policy.NIL &amp;&amp; ENTRY_COUNT &gt; 0\nauto evt = curs.next()\nevt.time = mkTime()\nevt.kidx = this.kidx\nevt.a1 = &lt;iarg_t&gt;a1\nevt.a2 = &lt;iarg_t&gt;a2\nevt.a3 = &lt;iarg_t&gt;a3\nend\nend\ndef EventKind.log(a1, a2, a3)\nthis.cache(a1, a2, a3) if POLICY == Policy.STORE || POLICY == Policy.QUIET\nthis.print(a1, a2, a3) if POLICY == Policy.PRINT\nend\ndef EventKind.print(a1, a2, a3)\nif POLICY &gt; Policy.QUIET\nvar evt: EventInst\nevt.time = mkTime()\nevt.kidx = this.kidx\nevt.a1 = &lt;iarg_t&gt;a1\nevt.a2 = &lt;iarg_t&gt;a2\nevt.a3 = &lt;iarg_t&gt;a3\nevt.put()\nend\nend\ndef Group.initH(gs)\nfor auto i = 0; i &lt; this.chars.length; i++\nthis.chars[i] = ^^gs &amp;&amp; gs[i] ? gs.charCodeAt(i) : \" \".charCodeAt(0)^^\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/MemDump/","title":"MemDump","text":""},{"location":"cargo/em.core/em.utils/MemDump/#unit-memdump","title":"unit MemDump","text":"em.utils/MemDump.em<pre><code>package em.utils\nmodule MemDump\nfunction print32(addr: ptr_t, count: uint8)\nend\ndef print32(addr, count)\nauto p32 = &lt;uint32*&gt;addr\nwhile count--\nauto v = *p32\nprintf \"%08x: %08x\\n\", p32, v\np32 += 1\nend\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/MinConsole/","title":"MinConsole","text":""},{"location":"cargo/em.core/em.utils/MinConsole/#unit-minconsole","title":"unit MinConsole","text":"em.utils/MinConsole.em<pre><code>package em.utils\nfrom em.lang import ConsoleProviderI\nfrom em.mcu import ConsoleUart\nimport Formatter\nmodule MinConsole: ConsoleProviderI\nend\ndef flush()\nConsoleUart.flush()\nend\ndef print(fmt, a1, a2, a3, a4, a5, a6)\nend\ndef put(data)\nConsoleUart.put(data)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/MsCounterUptimer/","title":"MsCounterUptimer","text":""},{"location":"cargo/em.core/em.utils/MsCounterUptimer/#unit-mscounteruptimer","title":"unit MsCounterUptimer","text":"em.utils/MsCounterUptimer.em<pre><code>package em.utils\nfrom em.hal import MsCounterI\nfrom em.hal import UptimerI\nmodule MsCounterUptimer: MsCounterI\nproxy Uptimer: UptimerI\nprivate:\nvar t0: uint32\nfunction readMsecs(): uint32\nend\ndef readMsecs()\nauto time = Uptimer.read()\nreturn ((time.secs &amp; 0xFF) &lt;&lt; 16) + (time.subs &gt;&gt; 16)\nend\ndef start()\nt0 = readMsecs()\nend\ndef stop()\nreturn 0 if t0 == 0\nauto dt = readMsecs() - t0\nt0 = 0\nreturn (dt * 1000) &gt;&gt; 16\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/PollerAux/","title":"PollerAux","text":""},{"location":"cargo/em.core/em.utils/PollerAux/#unit-polleraux","title":"unit PollerAux","text":"em.utils/PollerAux.em<pre><code>package em.utils\nfrom em.hal import OneShotMilliI\nfrom em.hal import PollerI\nfrom em.mcu import Common\nmodule PollerAux: PollerI\nproxy OneShot: OneShotMilliI\nconfig pauseOnly: bool = false\nprivate:\nfunction handler: OneShot.Handler\nfunction pause(msecs: uint32)\nvar doneFlag: bool volatile\nend\ndef handler(arg)\ndoneFlag = true\nend\ndef pause(msecs)\nreturn if msecs == 0\ndoneFlag = false\nOneShot.enable(msecs, handler, null)\nwhile !doneFlag\nCommon.Idle.exec()\nend\nend\ndef poll(rate, count, fxn)\nif pauseOnly\npause(rate)\nreturn 1\nelse\ncount = 0 if rate == 0\nwhile count\npause(rate)\ncount -= 1\nbreak if fxn &amp;&amp; fxn()\nend\nreturn count        end\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/ProcMgr/","title":"ProcMgr","text":""},{"location":"cargo/em.core/em.utils/ProcMgr/#unit-procmgr","title":"unit ProcMgr","text":"em.utils/ProcMgr.em<pre><code>package em.utils\nfrom em.mcu import Common\nfrom em.utils import BasicListManager\nmodule ProcMgr\ntype ProcFxn: function(arg: uarg_t)\ntype Proc: opaque\nhost function declareStartH()\nhost function initH(fxn: fxn_t, arg: uarg_t = 0)\nfunction arg(a: uarg_t)\nfunction fxn(f: fxn_t)\nfunction getArg(): uarg_t\nfunction getFxn(): fxn_t\nfunction post()\nend\nhost function createH(fxn: fxn_t, arg: uarg_t = 0): Proc&amp;\nfunction run()\nprivate:\ndef opaque Proc\nelem: BasicListManager.Element\nfxn_: fxn_t\narg_: uarg_t\nend\nfunction dispatch()\nconfig startP: Proc&amp;\nvar procList: BasicListManager.List\nend\ndef em$construct() \nprocList.initH()\nend\ndef em$startup()\nstartP.post() if startP &amp;&amp; !Common.Mcu.isWarm()\nend\ndef createH(fxn, arg)\nauto proc = new&lt;Proc&gt;\nproc.initH(fxn, arg)\nreturn proc\nend\ndef dispatch()\nfor ;;\nbreak if procList.hasElements() == 0\nauto proc = &lt;Proc&amp;&gt;procList.get()\nCommon.GlobalInterrupts.enable()\nauto fxn = &lt;ProcFxn&gt;proc.fxn_\nfxn(proc.arg_)\nCommon.GlobalInterrupts.disable()\nend   end\ndef run()\nCommon.Idle.wakeup()\nCommon.GlobalInterrupts.enable()\nfor ;;\nCommon.GlobalInterrupts.disable()\ndispatch()\nCommon.Idle.exec()\nend\nend\ndef Proc.declareStartH()\nstartP = this\nend\ndef Proc.initH(fxn, arg)\nthis.elem.initH()\nthis.fxn_ = fxn\nthis.arg_ = arg\nend\ndef Proc.arg(a)\nthis.arg_ = a\nend\ndef Proc.fxn(f)\nthis.fxn_ = f\nend\ndef Proc.getArg()\nreturn this.arg_\nend\ndef Proc.getFxn()\nreturn this.fxn_\nend\ndef Proc.post()\nauto key = Common.GlobalInterrupts.disable()\nprocList.add(this.elem) if !this.elem.isActive()\nCommon.GlobalInterrupts.restore(key)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/SoftUart/","title":"SoftUart","text":""},{"location":"cargo/em.core/em.utils/SoftUart/#unit-softuart","title":"unit SoftUart","text":"em.utils/SoftUart.em<pre><code>package em.utils\nfrom em.hal import ConsoleUartI\nfrom em.hal import GpioI\nfrom em.hal import UsThreshI\nfrom em.lang import Math\nfrom em.mcu import Common\nmodule SoftUart: ConsoleUartI\nproxy TxPin: GpioI\nproxy UsThresh: UsThreshI\nprivate:\nconfig baudRate: uint32 = 115200\nconfig bitTime: uint16 = 7\nend\ndef em$startup()\nTxPin.makeOutput()\nTxPin.set()\nend\ndef setBaudH(rate)\n## TODO -- implement\nend\ndef flush()\nend\ndef put(data)\nvar bitCnt: uint8 = 10                              # Load Bit counter, 8data + ST/SP/SP\nvar txByte: uint16 = (data &lt;&lt; 1) | 0x600            # Add mark stop bits and space start bit\nvar key: uarg_t = Common.GlobalInterrupts.disable()\nfor ;;\nUsThresh.set(bitTime)\nif bitCnt-- == 0\nTxPin.set()\nbreak\nelse\nif txByte &amp; 0x01\nTxPin.set()\nelse\nTxPin.clear()\nend\ntxByte = txByte &gt;&gt; 1                        # shift next bit\nend\nUsThresh.pause()\nend\nCommon.GlobalInterrupts.restore(key)\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/TickerMgr/","title":"TickerMgr","text":""},{"location":"cargo/em.core/em.utils/TickerMgr/#unit-tickermgr","title":"unit TickerMgr","text":"em.utils/TickerMgr.em<pre><code>package em.utils\nimport AlarmMgr\nimport FiberMgr\nmodule TickerMgr\n#   ^|\ntype TickCallback: function()\n#   ^|\ntype Ticker: opaque\n#   ^|\nhost function initH()\n#   ^|\nfunction start(rate256: uint32, tickCb: TickCallback)\n#   ^|        function stop()\n#   ^|        end\nhost function createH(): Ticker&amp;\n#   ^|\nprivate:\ndef opaque Ticker\nalarm: AlarmMgr.Alarm&amp;\nfiber: FiberMgr.Fiber&amp;\nrate256: uint32\ntickCb: TickCallback\nend\nfunction alarmFB: FiberMgr.FiberBodyFxn\nvar tickerTab: Ticker[]\nend\ndef createH()\nvar ticker: Ticker&amp; = tickerTab[tickerTab.length++]\nticker.initH()\nreturn ticker\nend\ndef Ticker.initH()\nthis.fiber = FiberMgr.createH(alarmFB, ^^this.$$cn^^)\nthis.alarm = AlarmMgr.createH(this.fiber)\nend\ndef alarmFB(arg)\nauto ticker = &lt;Ticker&amp;&gt;arg\nreturn if ticker.tickCb == null\nticker.tickCb() \nticker.alarm.wakeupAt(ticker.rate256)\nend\ndef Ticker.start(rate256, tickCb)\nthis.rate256 = rate256\nthis.tickCb = tickCb\nthis.alarm.wakeupAt(rate256)\nend\ndef Ticker.stop()\nthis.alarm.cancel()\nthis.tickCb = null\nend\n</code></pre>"},{"location":"cargo/em.core/em.utils/TimeoutAux/","title":"TimeoutAux","text":""},{"location":"cargo/em.core/em.utils/TimeoutAux/#unit-timeoutaux","title":"unit TimeoutAux","text":"em.utils/TimeoutAux.em<pre><code>package em.utils\nfrom em.hal import OneShotMilliI\nfrom em.hal import TimeoutI\nmodule TimeoutAux: TimeoutI\nproxy OneShot: OneShotMilliI\nprivate:\nvar flag: bool volatile\nfunction handler: OneShot.Handler\nend\ndef active()\nreturn flag\nend\ndef cancel()\nflag = false\nOneShot.disable()\nend\ndef handler(arg)\ncancel()\nend\ndef set(msecs)\nflag = true\nOneShot.enable(msecs, handler, null)\nend\n</code></pre>"},{"location":"cargo/em.docs/","title":"Index","text":""},{"location":"cargo/em.docs/#bundle-emdocs","title":"bundle em.docs","text":""},{"location":"cargo/em.docs/em.examples.basic/","title":"Index","text":""},{"location":"cargo/em.docs/em.examples.basic/#package-emexamplesbasic","title":"package em.examples.basic","text":""},{"location":"cargo/em.docs/em.examples.basic/Alarm1P/","title":"Alarm1P","text":""},{"location":"cargo/em.docs/em.examples.basic/Alarm1P/#unit-alarm1p","title":"unit Alarm1P","text":"em.examples.basic/Alarm1P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em.utils import AlarmMgr\nfrom em.utils import FiberMgr\nmodule Alarm1P\nprivate:\nfunction blinkFB: FiberMgr.FiberBodyFxn\nconfig alarm: AlarmMgr.Alarm&amp;\nconfig blinkF: FiberMgr.Fiber&amp;\nvar counter: uint32\nend\ndef em$construct()\nblinkF = FiberMgr.createH(blinkFB)\nalarm = AlarmMgr.createH(blinkF)\nend\ndef em$run()\nblinkF.post()\nFiberMgr.run()\nend\ndef blinkFB(arg)\n%%[c]\nAppLed.wink(100)            # 100ms\ncounter += 1\nif counter &amp; 0x1\nalarm.wakeup(512)       # 2s\nelse\nalarm.wakeup(192)       # 750ms\nend\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/Alarm2P/","title":"Alarm2P","text":""},{"location":"cargo/em.docs/em.examples.basic/Alarm2P/#unit-alarm2p","title":"unit Alarm2P","text":"em.examples.basic/Alarm2P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em.utils import AlarmMgr\nfrom em.utils import FiberMgr\nmodule Alarm2P\nprivate:\nfunction blinkFB: FiberMgr.FiberBodyFxn\nconfig alarm: AlarmMgr.Alarm&amp;\nconfig blinkF: FiberMgr.Fiber&amp;\nvar counter: uint32\nend\ndef em$construct()\nblinkF = FiberMgr.createH(blinkFB)\nalarm = AlarmMgr.createH(blinkF)\nend\ndef em$run()\nblinkF.post()\nFiberMgr.run()\nend\ndef blinkFB(arg)\n%%[c]\ncounter += 1\nif counter &amp; 0x1\nAppLed.wink(100)    # 100ms\nelse\nAppLed.wink(5)      # 5ms\nend\nalarm.wakeupAt(384)     # 1.5s window \nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/BlinkerDbgP/","title":"BlinkerDbgP","text":""},{"location":"cargo/em.docs/em.examples.basic/BlinkerDbgP/#unit-blinkerdbgp","title":"unit BlinkerDbgP","text":"em.examples.basic/BlinkerDbgP.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em.mcu import Common\nmodule BlinkerDbgP\nconfig dbgFlag: bool = true\nconfig minCnt: uint16 = 1000\nconfig maxCnt: uint16 = 1020 \nend\ndef em$run()\nAppLed.on()\nfor cnt: uint16 = minCnt; cnt &lt; maxCnt; cnt++\n%%[d+]\nCommon.BusyWait.wait(500 * 1000L)\n%%[d-]\nAppLed.toggle()\ncontinue if !dbgFlag\nfail if cnt &gt; ((minCnt + maxCnt) / 2)\n%%[&gt;cnt]\nvar bits11: uint8 = cnt &amp; 0b0011\n%%[&gt;bits11]\n%%[c:bits11]\nprintf \"cnt = %d (0x%04x), bits11 = %d\\n\", cnt, cnt, bits11\nend\nAppLed.off()\nhalt\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/BlinkerP/","title":"BlinkerP","text":""},{"location":"cargo/em.docs/em.examples.basic/BlinkerP/#unit-blinkerp","title":"unit BlinkerP","text":"em.examples.basic/BlinkerP.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em.mcu import Common\nmodule BlinkerP\nend\ndef em$run()\nAppLed.on()\nfor auto i = 0; i &lt; 10; i++\nCommon.BusyWait.wait(500 * 1000L)\nAppLed.toggle()\nend\nAppLed.off()\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/Button1P/","title":"Button1P","text":""},{"location":"cargo/em.docs/em.examples.basic/Button1P/#unit-button1p","title":"unit Button1P","text":"em.examples.basic/Button1P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em$distro import McuC\nfrom McuC import AppButEdge\nfrom em.mcu import Common\nmodule Button1P\nprivate:\nfunction handler: AppButEdge.Handler\nend\ndef em$construct()\nAppButEdge.setDetectHandlerH(handler)\nend\ndef em$startup()\nAppButEdge.makeInput()\nAppButEdge.setInternalPullup(true)\nAppButEdge.setDetectFallingEdge()\nend\ndef em$run()\nCommon.GlobalInterrupts.enable()\nfor ;;\nAppButEdge.enableDetect()\nCommon.Idle.exec()\nend\nend\ndef handler()\n%%[c]\nAppButEdge.clearDetect()\nAppLed.on()\nCommon.BusyWait.wait(5000)\nAppLed.off()\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/Button2P/","title":"Button2P","text":""},{"location":"cargo/em.docs/em.examples.basic/Button2P/#unit-button2p","title":"unit Button2P","text":"em.examples.basic/Button2P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em$distro import McuC\nfrom McuC import AppButEdge\nfrom em.mcu import Common\nfrom em.utils import FiberMgr\nmodule Button2P\nprivate:\nfunction blinkFB: FiberMgr.FiberBodyFxn\nfunction handler: AppButEdge.Handler\nconfig blinkF: FiberMgr.Fiber&amp;\nend\ndef em$construct()\nAppButEdge.setDetectHandlerH(handler)\nblinkF = FiberMgr.createH(blinkFB)\nend\ndef em$startup()\nAppButEdge.makeInput()\nAppButEdge.setInternalPullup(true)\nAppButEdge.setDetectFallingEdge()\nend\ndef em$run()\nAppButEdge.enableDetect()\nFiberMgr.run()\nend\ndef blinkFB(arg)\n%%[d]\nAppLed.on()\nCommon.BusyWait.wait(5000)\nAppLed.off()\nAppButEdge.enableDetect()\nend\ndef handler()\n%%[c]\nAppButEdge.clearDetect()\nblinkF.post()\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/Button3P/","title":"Button3P","text":""},{"location":"cargo/em.docs/em.examples.basic/Button3P/#unit-button3p","title":"unit Button3P","text":"em.examples.basic/Button3P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppBut\nfrom BoardC import AppLed\nfrom BoardC import SysLed\nfrom em.mcu import Common\nfrom em.utils import FiberMgr\nmodule Button3P\nprivate:\nfunction onPressedCB: AppBut.OnPressedCB\nend\ndef em$run()\nAppBut.onPressed(onPressedCB)\nFiberMgr.run()\nend\ndef onPressedCB()\n%%[c]\nif AppBut.isPressed()\nSysLed.on()\nCommon.BusyWait.wait(40000)  # 40ms\nSysLed.off()\nelse\nAppLed.on()\nCommon.BusyWait.wait(5000)  # 5ms\nAppLed.off()\nend\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/FiberP/","title":"FiberP","text":""},{"location":"cargo/em.docs/em.examples.basic/FiberP/#unit-fiberp","title":"unit FiberP","text":"em.examples.basic/FiberP.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em.mcu import Common\nfrom em.utils import FiberMgr\nmodule FiberP\nprivate:\nfunction blinkFB: FiberMgr.FiberBodyFxn\nconfig blinkF: FiberMgr.Fiber&amp;\nvar count: uint8 = 5\nend\ndef em$construct()\nblinkF = FiberMgr.createH(blinkFB)\nend\ndef em$run()\nblinkF.post()\nFiberMgr.run()\nend\ndef blinkFB(arg)\n%%[d]\nhalt if --count == 0\nAppLed.on()\nCommon.BusyWait.wait(100000)\nAppLed.off()\nCommon.BusyWait.wait(100000)\nblinkF.post()\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/HelloP/","title":"HelloP","text":""},{"location":"cargo/em.docs/em.examples.basic/HelloP/#unit-hellop","title":"unit HelloP","text":"em.examples.basic/HelloP.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nmodule HelloP\nend\ndef em$run()\nprintf \"hello world\\n\"\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/OneShot1P/","title":"OneShot1P","text":""},{"location":"cargo/em.docs/em.examples.basic/OneShot1P/#unit-oneshot1p","title":"unit OneShot1P","text":"em.examples.basic/OneShot1P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em$distro import McuC\nfrom McuC import OneShotMilli\nfrom em.mcu import Common\nmodule OneShot1P\nprivate:\nfunction handler: OneShotMilli.Handler\nvar doneFlag: bool volatile = true\nend\ndef em$run()\nCommon.GlobalInterrupts.enable()\nfor auto i = 0; i &lt; 5; i++\n%%[d]\nAppLed.on()\nCommon.BusyWait.wait(5000)\nAppLed.off()\ndoneFlag = false\nOneShotMilli.enable(100, handler)\nwhile !doneFlag\nCommon.Idle.exec()\nend\nend\nend\ndef handler(arg)\n%%[c]\ndoneFlag = true\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/OneShot2P/","title":"OneShot2P","text":""},{"location":"cargo/em.docs/em.examples.basic/OneShot2P/#unit-oneshot2p","title":"unit OneShot2P","text":"em.examples.basic/OneShot2P.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em$distro import McuC\nfrom McuC import OneShotMilli\nfrom em.mcu import Common\nfrom em.utils import FiberMgr\nmodule OneShot2P\nprivate:\nfunction blinkFB: FiberMgr.FiberBodyFxn\nfunction handler: OneShotMilli.Handler\nconfig blinkF: FiberMgr.Fiber&amp;\nvar count: uint8 = 5\nend\ndef em$construct()\nblinkF = FiberMgr.createH(blinkFB)\nend\ndef em$run()\nblinkF.post()\nFiberMgr.run()\nend\ndef blinkFB(arg)\n%%[d]\nAppLed.on()\nCommon.BusyWait.wait(5000)\nAppLed.off()\nhalt if --count == 0\nOneShotMilli.enable(100, handler, null)\nend\ndef handler(arg)\n%%[c]\nblinkF.post()\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/PollerP/","title":"PollerP","text":""},{"location":"cargo/em.docs/em.examples.basic/PollerP/#unit-pollerp","title":"unit PollerP","text":"em.examples.basic/PollerP.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom em.mcu import Common\nfrom em.mcu import Poller\nmodule PollerP\nend\ndef em$run()\nCommon.GlobalInterrupts.enable()\nauto k = 5\nwhile k--\nPoller.pause(100)   # 100ms\nAppLed.wink(5)      # 5ms\nend\nend\n</code></pre>"},{"location":"cargo/em.docs/em.examples.basic/TickerP/","title":"TickerP","text":""},{"location":"cargo/em.docs/em.examples.basic/TickerP/#unit-tickerp","title":"unit TickerP","text":"em.examples.basic/TickerP.em<pre><code>package em.examples.basic\nfrom em$distro import BoardC\nfrom BoardC import AppLed\nfrom BoardC import SysLed\nfrom em.utils import FiberMgr\nfrom em.utils import TickerMgr\nmodule TickerP\nprivate:\nfunction appTickCb: TickerMgr.TickCallback\nfunction sysTickCb: TickerMgr.TickCallback\nconfig appTicker: TickerMgr.Ticker&amp;\nconfig sysTicker: TickerMgr.Ticker&amp;\nend\ndef em$construct()\nappTicker = TickerMgr.createH()\nsysTicker = TickerMgr.createH()\nend\ndef em$run()\nappTicker.start(256, appTickCb)\nsysTicker.start(384, sysTickCb)\nFiberMgr.run()\nend\ndef appTickCb()\n%%[c]\nAppLed.wink(100)\nend\ndef sysTickCb()\n%%[d]\nSysLed.wink(100)\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/","title":"Index","text":""},{"location":"cargo/ti.cc23xx/#bundle-ticc23xx","title":"bundle ti.cc23xx","text":""},{"location":"cargo/ti.cc23xx/ti.build.cc23xx/","title":"Index","text":""},{"location":"cargo/ti.cc23xx/ti.build.cc23xx/#package-tibuildcc23xx","title":"package ti.build.cc23xx","text":""},{"location":"cargo/ti.cc23xx/ti.build.cc23xx/GccBuilder/","title":"GccBuilder","text":""},{"location":"cargo/ti.cc23xx/ti.build.cc23xx/GccBuilder/#unit-gccbuilder","title":"unit GccBuilder","text":"ti.build.cc23xx/GccBuilder.em<pre><code>package ti.build.cc23xx\nfrom em.build.misc import UniFlash\nfrom em.build.misc import Utils\nfrom em.build.gcc2 import BuilderBase as Base\nfrom em.lang import BuilderI\nfrom em.lang import BuildC\nmodule GccBuilder: BuilderI\nend\ndef em$configure()\nBase.gccFlav ?= \"arm-none-eabi\"\nif BuildC.bootFlash\nBase.dmemBase ?= 0x20005000\nBase.dmemSize ?= 0x4000\nBase.imemBase ?= 0x20000000\nBase.imemSize ?= 0x5000\nBase.lmemBase ?= 0x00000000\nBase.lmemSize ?= 0x80000\nelse\nBase.dmemBase ?= 0x20000000\nBase.dmemSize ?= 0x9000\nBase.imemBase ?= 0x00000000\nBase.imemSize ?= 0x80000\nend\nBase.vectSize ?= 0x90\nUtils.addInclude(\"com.ti/devices/cc23x0r5\")\nUtils.addSection(0x4e020000, 0x800, \"FLASH_CCFG\", \".ccfg\")\nend\ndef compile(buildDir)\nreturn &lt;CompileInfo&amp;&gt;Base.compile(buildDir)\nend\ndef getTypeInfo()\nreturn &lt;TypeInfo&amp;&gt;Base.getTypeInfo()\nend\ndef populate(buildDir, sysFlag)\nBase.populate(buildDir, sysFlag)\nUtils.copy(buildDir, \"CC2340R5.ccxml\", \"ti.build.cc23xx\")\nUniFlash.genLoadScript(buildDir, \"CC2340R5\")\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.build.cc23xx/SeggerBuilder/","title":"SeggerBuilder","text":""},{"location":"cargo/ti.cc23xx/ti.build.cc23xx/SeggerBuilder/#unit-seggerbuilder","title":"unit SeggerBuilder","text":"ti.build.cc23xx/SeggerBuilder.em<pre><code>package ti.build.cc23xx\nfrom em.build.misc import UniFlash\nfrom em.build.misc import Utils\nfrom em.build.segger2 import BuilderBase as Base\nfrom em.lang import BuilderI\nfrom em.lang import BuildC\nmodule SeggerBuilder: BuilderI\nend\ndef em$configure()\nif BuildC.bootFlash\nBase.dmemBase ?= 0x20005000\nBase.dmemSize ?= 0x4000\nBase.imemBase ?= 0x20000000\nBase.imemSize ?= 0x5000\nBase.lmemBase ?= 0x00000000\nBase.lmemSize ?= 0x80000\nelse\nBase.dmemBase ?= 0x20000000\nBase.dmemSize ?= 0x9000\nBase.imemBase ?= 0x00000000\nBase.imemSize ?= 0x80000\nend\nBase.vectSize ?= 0x90\nUtils.addInclude(\"com.ti/devices/cc23x0r5\")\nUtils.addInclude(\"com.ti/devices/cc23x0r5/cmsis/core\")\nUtils.addSection(0x4e020000, 0x800, \"FLASH_CCFG\", \".ccfg\")\nend\ndef compile(buildDir)\nreturn &lt;CompileInfo&amp;&gt;Base.compile(buildDir)\nend\ndef getTypeInfo()\nreturn &lt;TypeInfo&amp;&gt;Base.getTypeInfo()\nend\ndef populate(buildDir, sysFlag)\nBase.populate(buildDir, sysFlag)\nUtils.copy(buildDir, \"CC2340R5.ccxml\", \"ti.build.cc23xx\")\nUniFlash.genLoadScript(buildDir, \"CC2340R5\")\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/","title":"Index","text":""},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/#package-tidistrocc23xx","title":"package ti.distro.cc23xx","text":""},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/BoardC/","title":"BoardC","text":""},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/BoardC/#unit-boardc","title":"unit BoardC","text":"ti.distro.cc23xx/BoardC.em<pre><code>package ti.distro.cc23xx\nfrom em.lang import Atom                    # force ordering\nimport McuC\nfrom McuC import AppButEdge\nfrom McuC import AppLedPin\nfrom McuC import AppOutPin\nfrom McuC import AppOutUart\nfrom McuC import SysDbgA\nfrom McuC import SysDbgB\nfrom McuC import SysDbgC\nfrom McuC import SysDbgD\nfrom McuC import SysLedPin\nfrom McuC import OneShotMilli\nfrom McuC import Uptimer\nfrom McuC import WakeupTimer\nfrom em.lang import Console\nfrom em.lang import Debug\nfrom em.mcu import ConsoleUart\nfrom em.mcu import Poller\nfrom em.utils import AlarmMgr\nfrom em.utils import BoardController\nfrom em.utils import BoardInfo\nfrom em.utils import EpochTime\nfrom em.utils import FormattingConsole\nfrom em.utils import PollerAux\nfrom em.utils import DebugPinT {} as DbgA\nfrom em.utils import DebugPinT {} as DbgB\nfrom em.utils import DebugPinT {} as DbgC\nfrom em.utils import DebugPinT {} as DbgD\nfrom em.utils import LedT {} as AppLed\nfrom em.utils import LedT {} as SysLed\nfrom em.utils import ButtonT {} as AppBut\nexport AppBut\nexport AppLed\nexport SysLed\ncomposite BoardC\nend\ndef em$configure()\nauto brdRec = BoardInfo.readRecordH()\nauto pm = brdRec.pinMap\nAlarmMgr.WakeupTimer ?= WakeupTimer\nAppBut.Edge ?= AppButEdge\nAppLed.activeLow ?= brdRec.activeLowLeds\nAppLed.em$used ?= true\nAppLed.Pin ?= AppLedPin\nAppOutUart.TxPin ?= AppOutPin\nBoardController.em$used ?= true\nBoardController.Led ?= SysLed\nConsole.em$used ?= true\nConsole.Provider ?= FormattingConsole\nConsoleUart.Impl ?= AppOutUart\nDbgA.Pin ?= SysDbgA\nDbgB.Pin ?= SysDbgB\nDbgC.Pin ?= SysDbgC\nDbgD.Pin ?= SysDbgD\nDebug.Pin_a ?= DbgA\nDebug.Pin_b ?= DbgB\nDebug.Pin_c ?= DbgC\nDebug.Pin_d ?= DbgD\nEpochTime.Uptimer ?= Uptimer\nPoller.Impl ?= PollerAux\nPollerAux.OneShot ?= OneShotMilli\nSysLed.activeLow ?= brdRec.activeLowLeds\nSysLed.em$used ?= true\nSysLed.Pin ?= SysLedPin\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/BoardMeta/","title":"BoardMeta","text":""},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/BoardMeta/#unit-boardmeta","title":"unit BoardMeta","text":"ti.distro.cc23xx/BoardMeta.em<pre><code>package ti.distro.cc23xx\nfrom em.utils import BoardMeta as BaseMeta\nhost module BoardMeta\ntype DrvDesc: BaseMeta.DrvDesc\ntype PinMap: struct\nappBut: int8\nappLed: int8\nappOut: int8\nextFlashCS: int8\nextFlashCLK: int8\nextFlashPICO: int8\nextFlashPOCI: int8\nsysDbgA: int8\nsysDbgB: int8\nsysDbgC: int8\nsysDbgD: int8\nsysLed: int8\nend\ntype Record: struct\nactiveLowLeds: bool\nbaudRate: uint32\nclockFreq: uint32\nextFlashDisable: bool\nlfXtalEnable: bool\npinMap: PinMap&amp;\ndrvDescs: DrvDesc&amp;[]\nend\nconfig baseFileLoc: string = \"ti.distro.cc23xx/em-boards\"\nconfig attrNames: string[] = [\n\"$inherits\",\n\"$overrides\",\n\"activeLowLeds\",\n\"baudRate\",\n\"clockFreq\",\n\"extFlashDisable\",\n\"lfXtalEnable\",\n    ]\nconfig pinNames: string[] = [\n\"appBut\",\n\"appLed\",\n\"appOut\",\n\"extFlashCS\",\n\"extFlashCLK\",\n\"extFlashPICO\",\n\"extFlashPOCI\",\n\"sysDbgA\",\n\"sysDbgB\",\n\"sysDbgC\",\n\"sysDbgD\",\n\"sysLed\",\n    ] \nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/McuC/","title":"McuC","text":""},{"location":"cargo/ti.cc23xx/ti.distro.cc23xx/McuC/#unit-mcuc","title":"unit McuC","text":"ti.distro.cc23xx/McuC.em<pre><code>package ti.distro.cc23xx\nfrom ti.mcu.cc23xx import Regs     # force ordering\nfrom ti.mcu.cc23xx import EdgeDetectGpioT {} as AppButEdge\nfrom ti.mcu.cc23xx import GpioT {} as AppLedPin\nfrom ti.mcu.cc23xx import GpioT {} as AppOutPin\nfrom ti.mcu.cc23xx import GpioT {} as SysDbgA\nfrom ti.mcu.cc23xx import GpioT {} as SysDbgB\nfrom ti.mcu.cc23xx import GpioT {} as SysDbgC\nfrom ti.mcu.cc23xx import GpioT {} as SysDbgD\nfrom ti.mcu.cc23xx import GpioT {} as SysLedPin\nfrom ti.mcu.cc23xx import ConsoleUart0 as AppOutUart\nfrom ti.mcu.cc23xx import BusyWait\nfrom ti.mcu.cc23xx import ExtFlashDisabler\nfrom ti.mcu.cc23xx import GlobalInterrupts\nfrom ti.mcu.cc23xx import Idle\nfrom ti.mcu.cc23xx import IntrVec\nfrom ti.mcu.cc23xx import Mcu\nfrom ti.mcu.cc23xx import MsCounter\nfrom ti.mcu.cc23xx import OneShotGpt3 as OneShotMilli\nfrom ti.mcu.cc23xx import Uptimer\nfrom ti.mcu.cc23xx import WakeupTimer\nfrom em.mcu import Common\nfrom em.mcu import CommonC\nfrom em.utils import BoardInfo\nexport AppButEdge\nexport AppLedPin\nexport AppOutPin\nexport AppOutUart\nexport OneShotMilli\nexport SysDbgA\nexport SysDbgB\nexport SysDbgC\nexport SysDbgD\nexport SysLedPin\nexport Uptimer\nexport WakeupTimer\ncomposite McuC\nend\ndef em$preconfigure()\nauto brdRec = BoardInfo.readRecordH()\nauto pm = brdRec.pinMap\nAppButEdge.pin ?= pm.appBut\nAppLedPin.pin ?= pm.appLed\nAppOutPin.pin ?= pm.appOut\nAppOutUart.setBaudH(brdRec.baudRate)\nExtFlashDisabler.em$used ?= brdRec.extFlashDisable\nExtFlashDisabler.CLK_pin ?= pm.extFlashCLK\nExtFlashDisabler.CS_pin ?= pm.extFlashCS\nExtFlashDisabler.PICO_pin ?= pm.extFlashPICO\nExtFlashDisabler.POCI_pin ?= pm.extFlashPOCI\nIntrVec.em$used ?= true\nMcu.hasLfXtal ?= brdRec.lfXtalEnable\nMcu.mclkFrequency ?= brdRec.clockFreq\nRegs.em$used ?= true\nSysDbgA.pin ?= pm.sysDbgA\nSysDbgB.pin ?= pm.sysDbgB\nSysDbgC.pin ?= pm.sysDbgC\nSysDbgD.pin ?= pm.sysDbgD\nSysLedPin.pin ?= pm.sysLed\nend\ndef em$configure()\nCommon.BusyWait ?= BusyWait\nCommon.GlobalInterrupts ?= GlobalInterrupts\nCommon.Idle ?= Idle\nCommon.Mcu ?= Mcu\nCommon.MsCounter ?= MsCounter\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/","title":"Index","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/#package-timcucc23xx","title":"package ti.mcu.cc23xx","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/BusyWait/","title":"BusyWait","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/BusyWait/#unit-busywait","title":"unit BusyWait","text":"ti.mcu.cc23xx/BusyWait.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import BusyWaitI\nmodule BusyWait: BusyWaitI\nend\ndef wait(usecs)\n^HapiWaitUs(usecs)\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/BusyWaitSysTick/","title":"BusyWaitSysTick","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/BusyWaitSysTick/#unit-busywaitsystick","title":"unit BusyWaitSysTick","text":"ti.mcu.cc23xx/BusyWaitSysTick.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import BusyWaitI\nmodule BusyWaitSysTick: BusyWaitI\nend\ndef wait(usecs)\n^^SysTick-&gt;VAL^^ = 0\n^^SysTick-&gt;LOAD^^ = usecs\n^^SysTick-&gt;CTRL |= SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk^^\nwhile ^^SysTick-&gt;CTRL &amp; SysTick_CTRL_COUNTFLAG_Msk^^ != 0\n%%[d]\nend\n^^SysTick-&gt;CTRL^^ = 0\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/ConsoleUart0/","title":"ConsoleUart0","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/ConsoleUart0/#unit-consoleuart0","title":"unit ConsoleUart0","text":"ti.mcu.cc23xx/ConsoleUart0.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import ConsoleUartI\nfrom em.hal import GpioI\nfrom em.lang import Math\nimport Idle\nimport Mcu\nmodule ConsoleUart0: ConsoleUartI\nproxy TxPin: GpioI\nprivate:\nconfig baud: uint32\nconfig fbrd: uint32\nconfig ibrd: uint32\nfunction sleepEnter: Idle.Callback\nfunction sleepLeave: Idle.Callback\nend\ndef em$construct()\nIdle.addSleepEnterCbH(sleepEnter)\nIdle.addSleepLeaveCbH(sleepLeave)\nauto brd = &lt;num_t&gt;(Mcu.mclkFrequency / (baud * 16))\nibrd = Math.floor(brd)\nfbrd = Math.round((brd - ibrd) * 64)\nend\ndef em$startup()\nsleepLeave()\nend\ndef setBaudH(rate)\nbaud = rate\nend\ndef sleepEnter()\n^^HWREG(CLKCTL_BASE + CLKCTL_O_CLKENCLR0)^^ = ^CLKCTL_CLKENSET0_UART0\nTxPin.reset()\nend\ndef sleepLeave()\n^^HWREG(CLKCTL_BASE + CLKCTL_O_CLKENSET0)^^ = ^CLKCTL_CLKENSET0_UART0\nTxPin.makeOutput()\nTxPin.set()\nTxPin.functionSelect(2)\n^^HWREG(UART0_BASE + UART_O_CTL)^^ &amp;= ~^UART_CTL_UARTEN\n^^HWREG(UART0_BASE + UART_O_IBRD)^^ = ibrd\n^^HWREG(UART0_BASE + UART_O_FBRD)^^ = fbrd\n^^HWREG(UART0_BASE + UART_O_LCRH)^^ = ^UART_LCRH_WLEN_BITL8\n^^HWREG(UART0_BASE + UART_O_CTL)^^ |= ^UART_CTL_UARTEN\nend\ndef flush()\nwhile (^^HWREG(UART0_BASE + UART_O_FR)^^ &amp; ^UART_FR_BUSY) != 0\nend\nend\ndef put(data)\n^^HWREG(UART0_BASE + UART_O_DR)^^ = data\nflush()\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/EdgeDetectGpioAux/","title":"EdgeDetectGpioAux","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/EdgeDetectGpioAux/#unit-edgedetectgpioaux","title":"unit EdgeDetectGpioAux","text":"ti.mcu.cc23xx/EdgeDetectGpioAux.em<pre><code>package ti.mcu.cc23xx\nimport InterruptT { name: \"GPIO_COMB\" } as Intr\nmodule EdgeDetectGpioAux\ntype Handler: function ()\ntype HandlerInfo: struct\nlink: HandlerInfo&amp;\nmask: uint32\nhandler: Handler\nend\nfunction addHandler(hi: HandlerInfo&amp;)\nprivate:\nvar handlerList: HandlerInfo&amp;\nfunction edgeIsr: Intr.Handler\nend\ndef em$construct()\nIntr.setHandlerH(edgeIsr)\nend\ndef em$startup()\nIntr.enable()\nend\ndef addHandler(hi)\nhi.link = handlerList\nhandlerList = hi\nend\ndef edgeIsr()\nauto mis = &lt;uint32&gt;^^HWREG(GPIO_BASE + GPIO_O_MIS)^^\nfor hi: HandlerInfo&amp; = handlerList; hi != null; hi = hi.link\nhi.handler() if (mis &amp; hi.mask) &amp;&amp; hi.handler\nend\n^^HWREG(GPIO_BASE + GPIO_O_ICLR)^^ = 0xffffffff\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/EdgeDetectGpioT/","title":"EdgeDetectGpioT","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/EdgeDetectGpioT/#unit-edgedetectgpiot","title":"unit EdgeDetectGpioT","text":"ti.mcu.cc23xx/EdgeDetectGpioT.em<pre><code>package ti.mcu.cc23xx\ntemplate EdgeDetectGpioT\nconst UNDEF: int8 = -1\nconfig pin: int8 = UNDEF\nend\ndef em$generateUnit(pn, un)\nauto bq = \"`\"\nauto p = pin\nauto pre = ^^pn.replace(/[.]/g, '_') + '_' + un + '__'^^\n|-&gt;&gt;&gt;\n    package `pn`\n    from ti.mcu.cc23xx import EdgeDetectGpioAux as Aux\n    from ti.mcu.cc23xx import GpioT {} as Pin\n    from em.hal import GpioEdgeDetectMinI\n    module `un`: GpioEdgeDetectMinI\n        config pin: int16 = `p`\n    private:\n        config isDef: bool\n        config mask: uint32        \n        var info: Aux.HandlerInfo\n    end\n    def em$configure()\n        Pin.pin ?= pin\n    end\n    def em$construct()\n        isDef = pin != `UNDEF`\n        mask = isDef ? &lt;uint32&gt;(1 &lt;&lt; &lt;uint8&gt;pin) : 0\n        info.mask = mask\n    end\n    def em$startup()\n        Aux.addHandler(info)\n    end    \n    def clear() \n        Pin.clear()\n    end\n    def set()\n        Pin.set()\n    end\n    def get()\n        return Pin.get()\n    end\n    def toggle()\n        Pin.toggle()\n    end\n    def isInput()\n        return Pin.isInput()\n    end\n    def isOutput()\n        return Pin.isOutput()\n    end\n    def makeInput()\n        Pin.makeInput()\n    end\n    def makeOutput()\n        Pin.makeOutput()\n    end\n    def functionSelect(select)\n        Pin.functionSelect(select)\n    end\n    def setInternalPullup(enable)\n        Pin.setInternalPullup(enable)\n    end\n    def pinId()\n        return pin\n    end\n    def reset()\n        Pin.reset()\n    end\n    def enableDetect()\n        ^^HWREG(GPIO_BASE + GPIO_O_IMSET)^^ = mask if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ |= ^IOC_IOC0_WUENSB if isDef\n    end\n    def disableDetect()\n        ^^HWREG(GPIO_BASE + GPIO_O_IMCLR)^^ = mask if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ &amp;= ~^IOC_IOC0_WUENSB if isDef\n    end\n    def clearDetect()\n        ^^HWREG(GPIO_BASE + GPIO_O_ICLR)^^ = mask if isDef\n    end\n    def setDetectRisingEdge()\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ &amp;= ~^IOC_IOC0_EDGEDET_M if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ |= ^IOC_IOC0_EDGEDET_EDGE_POS if isDef\n    end\n    def setDetectFallingEdge()\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ &amp;= ~^IOC_IOC0_EDGEDET_M if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ |= ^IOC_IOC0_EDGEDET_EDGE_NEG if isDef\n    end\n    def setDetectHandlerH(h)\n        info.handler = &lt;Aux.Handler&gt;h\n    end\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/ExtFlashDisabler/","title":"ExtFlashDisabler","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/ExtFlashDisabler/#unit-extflashdisabler","title":"unit ExtFlashDisabler","text":"ti.mcu.cc23xx/ExtFlashDisabler.em<pre><code>package ti.mcu.cc23xx\nimport GpioT {} as CS\nimport GpioT {} as CLK\nimport GpioT {} as PICO\nimport GpioT {} as POCI\nfrom em.mcu import Common\nmodule ExtFlashDisabler\nconfig CS_pin: int8\nconfig CLK_pin: int8\nconfig PICO_pin: int8\nconfig POCI_pin: int8\nprivate:\nconst SD_CMD: uint8 = 0xb9\nend\ndef em$construct()\nCS.pin = CS_pin\nCLK.pin = CLK_pin\nPICO.pin = PICO_pin\nPOCI.pin = POCI_pin\nend\ndef em$startup()\n%%[c+]\nCS.makeOutput()\nCLK.makeOutput()\nPICO.makeOutput()\nPOCI.makeInput()\n# attention\nCS.set()\nCommon.BusyWait.wait(1)\nCS.clear()\nCommon.BusyWait.wait(1)\nCS.set()\nCommon.BusyWait.wait(50)\n# shutdown command\nCS.clear()\nfor auto i = 0; i &lt; 8; i++\nCLK.clear()\nif ((SD_CMD &gt;&gt; (7 - i)) &amp; 0x01) == 0\nPICO.clear()\nelse\nPICO.set()\nend\nCLK.set()\nCommon.BusyWait.wait(1)\nend\nCLK.clear()\nCS.set()\nCommon.BusyWait.wait(50)\n#\nCS.reset()\nCLK.reset()\nPICO.reset()\nPOCI.reset()\n%%[c-]\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/GlobalInterrupts/","title":"GlobalInterrupts","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/GlobalInterrupts/#unit-globalinterrupts","title":"unit GlobalInterrupts","text":"ti.mcu.cc23xx/GlobalInterrupts.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import GlobalInterruptsI\nmodule GlobalInterrupts: GlobalInterruptsI\nend\ndef disable()\nauto key = &lt;uarg_t&gt;(^^__get_PRIMASK()^^)\n^^__set_PRIMASK(1)^^\nreturn key\nend\ndef enable()\n^^__set_PRIMASK(0)^^\nend\ndef restore(key)\n^^__set_PRIMASK(key)^^\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/GpioT/","title":"GpioT","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/GpioT/#unit-gpiot","title":"unit GpioT","text":"ti.mcu.cc23xx/GpioT.em<pre><code>package ti.mcu.cc23xx\ntemplate GpioT\nconst UNDEF: int16 = -1\nconfig pin: int16 = UNDEF\nend\ndef em$generateUnit(pn, un)\nauto bq = \"`\"\nauto pre = ^^pn.replace(/[.]/g, '_') + '_' + un + '__'^^\n|-&gt;&gt;&gt;\n    package `pn`\n    from em.hal import GpioI\n    module `un`: GpioI\n        config pin: int16 = `pin`\n        function pinMask(): uint32    \n    private:\n        config isDef: bool\n        config mask: uint32\n    end\n    def em$construct()\n        isDef = pin != `UNDEF`\n        mask = isDef ? &lt;uint32&gt;(1 &lt;&lt; &lt;uint8&gt;pin) : 0\n    end\n    def clear() \n        ^^HWREG(GPIO_BASE + GPIO_O_DOUTCLR31_0)^^ = mask if isDef\n    end\n    def set()\n        ^^HWREG(GPIO_BASE + GPIO_O_DOUTSET31_0)^^ = mask if isDef\n    end\n    def get()\n        return 0 if !isDef\n        return isInput() ? ((^^HWREG(GPIO_BASE + GPIO_O_DIN31_0)^^ &amp; mask) != 0) : ((^^HWREG(GPIO_BASE + GPIO_O_DOUT31_0)^^ &amp; mask) != 0)\n    end\n    def toggle()\n        ^^HWREG(GPIO_BASE + GPIO_O_DOUTTGL31_0)^^ = mask if isDef\n    end\n    def isInput()\n        return isDef &amp;&amp; (^^HWREG(GPIO_BASE + GPIO_O_DOE31_0)^^ &amp; mask) == 0\n    end\n    def isOutput()\n        return isDef &amp;&amp; (^^HWREG(GPIO_BASE + GPIO_O_DOE31_0)^^ &amp; mask) != 0\n    end\n    def makeInput()\n        ^^HWREG(GPIO_BASE + GPIO_O_DOECLR31_0)^^ = mask if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ |= ^IOC_IOC0_INPEN if isDef\n    end\n    def makeOutput()\n        ^^HWREG(GPIO_BASE + GPIO_O_DOESET31_0)^^ = mask if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ &amp;= ~^IOC_IOC0_INPEN if isDef\n    end\n    def functionSelect(select)\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ = select if isDef\n    end\n    def setInternalPullup(enable)\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ |= ^IOC_IOC0_PULLCTL_PULL_UP if isDef &amp;&amp; enable\n    end\n    def pinId()\n        return pin\n    end\n    def pinMask()\n        return mask\n    end\n    def reset()\n        ^^HWREG(GPIO_BASE + GPIO_O_DOECLR31_0)^^ = mask if isDef\n        ^^HWREG(IOC_BASE + IOC_O_IOC0 + pin * 4)^^ |= (^IOC_IOC0_IOMODE_M | ^IOC_IOC0_PULLCTL_M) if isDef\n    end\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Idle/","title":"Idle","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Idle/#unit-idle","title":"unit Idle","text":"ti.mcu.cc23xx/Idle.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import IdleI\nfrom em.lang import Debug\nmodule Idle: IdleI\ntype Callback: function()\nhost function addSleepEnterCbH(cb: Callback) \nhost function addSleepLeaveCbH(cb: Callback) \nfunction doSleep()\nfunction doWait()\nfunction setWaitOnly(val: bool)\nprivate:\nconfig sleepEnterCbTab: Callback[..]\nconfig sleepLeaveCbTab: Callback[..]\nvar waitOnly: bool\nend\ndef em$startup()\n%%[b+]\n^^HWREG(PMCTL_BASE + PMCTL_O_VDDRCTL)^^ = ^PMCTL_VDDRCTL_SELECT     # LDO\n^^HWREG(EVTULL_BASE + EVTULL_O_WKUPMASK)^^ = ^EVTULL_WKUPMASK_AON_RTC_COMB | ^EVTULL_WKUPMASK_AON_IOC_COMB\nend\ndef addSleepEnterCbH(cb)\nsleepEnterCbTab[sleepEnterCbTab.length++] = cb\nend\ndef addSleepLeaveCbH(cb)\nsleepLeaveCbTab[sleepLeaveCbTab.length++] = cb\nend\ndef doSleep()\nfor cb in sleepEnterCbTab\ncb()\nend\n%%[b:2]\n%%[b-]\nDebug.sleepEnter()\n^^HWREG(CKMD_BASE + CKMD_O_LDOCTL)^^ = 0x0\n^^__set_PRIMASK(1)^^\n^^HapiEnterStandby(NULL)^^\nDebug.sleepLeave()\n%%[b+]\nfor cb in sleepLeaveCbTab\ncb()\nend\n^^__set_PRIMASK(0)^^\nend\ndef doWait()\n%%[b:1]\n%%[b-]\n^^__set_PRIMASK(1)^^\n^^asm(\"wfi\")^^\n%%[b+]\n^^__set_PRIMASK(0)^^\nend\ndef exec()\nif waitOnly\ndoWait()\nelse\ndoSleep()\nend\nend\ndef setWaitOnly(val)\nwaitOnly = val\nend\ndef wakeup()\n## TODO -- implement\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/InterruptT/","title":"InterruptT","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/InterruptT/#unit-interruptt","title":"unit InterruptT","text":"ti.mcu.cc23xx/InterruptT.em<pre><code>package ti.mcu.cc23xx\ntemplate InterruptT\nconfig name: string\nend\ndef em$generateUnit(pn, un) \nauto intrName = name\nauto handlerNameQ = \"`\" + un + \".handlerName`\"\n|-&gt;&gt;&gt;\n    package `pn`\n    from ti.mcu.cc23xx import IntrVec\n    from em.hal import InterruptSourceI\n    module `un`: InterruptSourceI \n    private:\n        host var handlerName: string\n    end\n    def em$construct()\n        IntrVec.addIntrH(\"`intrName`\")\n    end\n    def em$generateCode( prefix )\n        if `un`.handlerName\n            |-&gt; void `intrName`_Handler() {\n            |-&gt;     `handlerNameQ`();\n            |-&gt; }\n        end\n    end\n    def setHandlerH(h)\n        handlerName = h ? ^^String(h).substring(1)^^ : null\n    end\n    def enable() \n        ^^NVIC_EnableIRQ(`intrName`_IRQn)^^\n    end\n    def disable() \n        ^^NVIC_DisableIRQ(`intrName`_IRQn)^^\n    end\n    def clear()\n        ^^NVIC_ClearPendingIRQ(`intrName`_IRQn)^^\n    end\n    def isEnabled() \n        return ^^NVIC_GetEnableIRQ(`intrName`_IRQn)^^\n    end\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/IntrVec/","title":"IntrVec","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/IntrVec/#unit-intrvec","title":"unit IntrVec","text":"ti.mcu.cc23xx/IntrVec.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import IntrVecI\nmodule IntrVec: IntrVecI\nhost function addIntrH(name: string)\nprivate:\nconst HARD_FAULT: uint32 = 3\ntype IsrFxn: function()\nhost config nameTab: string[] = [\n\"NMI\",\n\"HardFault\",\nnull,\nnull,\nnull,\nnull,\nnull,\nnull,\nnull,\n\"SVC\",\nnull,\nnull,\n\"PendSV\",\n\"SysTick\",\n\"CPUIRQ0\",\n\"CPUIRQ1\",\n\"CPUIRQ2\",\n\"CPUIRQ3\",\n\"CPUIRQ4\",\n\"GPIO_COMB\",     \n\"LRFD_IRQ0\",     \n\"LRFD_IRQ1\",     \n\"DMA_DONE_COMB\",     \n\"AES_COMB\",      \n\"SPI0_COMB\",     \n\"UART0_COMB\",    \n\"I2C0_IRQ\",     \n\"LGPT0_COMB\",    \n\"LGPT1_COMB\",    \n\"ADC0_COMB\",     \n\"CPUIRQ16\", \n\"LGPT2_COMB\",    \n\"LGPT3_COMB\",\n    ]\nhost config usedTab: string[]\nconfig excHandler: ExceptionHandler\nfunction nullIsr()\nend\ndef em$generateCode(prefix)\n|-&gt;&gt;&gt;\ntypedef void( *intfunc )( void );\ntypedef union { intfunc fxn; void* ptr; } intvec_elem;\n|-&lt;&lt;&lt;\nfor n in nameTab\ncontinue if n == null\n        |-&gt; extern void `n`_Handler( void );\n        |-&gt; #define `n`_ISR `prefix`::nullIsr\nend    |-&gt;&gt;&gt;\n|-&lt;&lt;&lt;\nfor u in usedTab\n        |-&gt; #undef `u`_ISR\n        |-&gt; #define `u`_ISR `u`_Handler\nend    |-&gt;&gt;&gt;\nextern em_uint32 __stack_top__;\nextern \"C\" void __em_program_start( void );\nextern \"C\" const intvec_elem  __attribute__((section(\".intvec\"))) __vector_table[] = {\n    { .ptr = (void*)&amp;__stack_top__ },\n    { .fxn = __em_program_start },\n|-&lt;&lt;&lt;\nfor n in nameTab\nif n == null\n            |-&gt;     0,\nelse\n            |-&gt;     { .fxn = `n`_ISR },\nend\nend        |-&gt; };\n|-&gt;&gt;&gt;\n|-&lt;&lt;&lt;\nend\ndef em$startup()\n^^SCB-&gt;VTOR = (uint32_t)(&amp;__vector_table)^^\nend\ndef addIntrH(name)\nusedTab[usedTab.length++] = name\nend\ndef bindExceptionHandlerH(handler)\nexcHandler = handler\nend\ndef nullIsr()\nauto vecNum = &lt;uint32&gt;(^^__get_IPSR()^^)\n%%[b:4]\n%%[&gt;&lt;uint8&gt;vecNum]\nauto frame = &lt;uint32[]&gt;(^^__get_MSP()^^)\n%%[&gt;&lt;uint32&gt;&amp;frame[0]]\nfor auto i = 0; i &lt; 8; i++\n%%[b]\n%%[&gt;frame[i]]\nend\nfail\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Mcu/","title":"Mcu","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Mcu/#unit-mcu","title":"unit Mcu","text":"ti.mcu.cc23xx/Mcu.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import McuI\nfrom em.lang import Debug\nmodule Mcu: McuI\nconfig noCache: bool\nconfig hasLfXtal: bool\nend\ndef getResetCode()\n## TODO -- implement\nreturn 0\nend\ndef getStashAddr()\n## TODO -- implement\nreturn null\nend\ndef isWarm()\n## TODO -- implement\nreturn false\nend\ndef readEui48(dst)\n## TODO -- implement\nend\ndef reset(code)\n## TODO -- implement\nend\ndef startup()\nDebug.startup()\nif hasLfXtal\n^^HWREG(CKMD_BASE + CKMD_O_LFINCOVR) = 0x001E8480 | CKMD_LFINCOVR_OVERRIDE_M^^\n^^HWREG(CKMD_BASE + CKMD_O_LFCLKSEL) = CKMD_LFCLKSEL_MAIN_LFXT^^\n^^HWREG(CKMD_BASE + CKMD_O_LFXTCTL) = CKMD_LFXTCTL_EN^^\n^^HWREG(CKMD_BASE + CKMD_O_IMSET) = CKMD_IMASK_LFCLKGOOD^^\nelse\n^^HWREG(CKMD_BASE + CKMD_O_TRIM1) |= CKMD_TRIM1_NABIAS_LFOSC^^\n^^HWREG(CKMD_BASE + CKMD_O_LFCLKSEL) = CKMD_LFCLKSEL_MAIN_LFOSC^^\n^^HWREG(CKMD_BASE + CKMD_O_LFOSCCTL) = CKMD_LFOSCCTL_EN^^\n^^HWREG(CKMD_BASE + CKMD_O_LFINCCTL) &amp;= ~CKMD_LFINCCTL_PREVENTSTBY_M^^\n^^HWREG(CKMD_BASE + CKMD_O_IMSET) = CKMD_IMASK_LFCLKGOOD^^\nend\n^^HWREG(CLKCTL_BASE + CLKCTL_O_IDLECFG)^^ = 1 if noCache\n^^HWREG(VIMS_BASE + VIMS_O_CCHCTRL)^^ = 0 if noCache\nend\ndef shutdown()\n## TODO -- implement\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/MsCounter/","title":"MsCounter","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/MsCounter/#unit-mscounter","title":"unit MsCounter","text":"ti.mcu.cc23xx/MsCounter.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import MsCounterI\nimport Rtc\nmodule MsCounter: MsCounterI\nprivate:\nvar t0: uint32\nend\ndef start()\nt0 = Rtc.getMsecs()\nend\ndef stop()\nreturn 0 if t0 == 0\nauto t1 = Rtc.getMsecs()\nauto dt = (t1 &gt; t0) ? (t1 - t0) : (t0 - t1)\nt0 = 0\nreturn dt\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/OneShotGpt3/","title":"OneShotGpt3","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/OneShotGpt3/#unit-oneshotgpt3","title":"unit OneShotGpt3","text":"ti.mcu.cc23xx/OneShotGpt3.em<pre><code>package ti.mcu.cc23xx\nimport InterruptT { name: \"LGPT3_COMB\" } as Intr\nimport BusyWait\nimport Idle\nimport Mcu\nfrom em.hal import OneShotMilliI\nmodule OneShotGpt3: OneShotMilliI\nprivate:\nvar curArg: ptr_t\nvar curFxn: Handler\nfunction isr: Intr.Handler\nend\ndef em$construct()\nIntr.setHandlerH(isr)\nend\ndef disable()\ncurFxn = null\nIdle.setWaitOnly(false)\nIntr.disable()\n^^HWREG(LGPT3_BASE + LGPT_O_ICLR) = LGPT_ICLR_TGT^^\nend\ndef enable(msecs, handler, arg)\ncurFxn = handler\ncurArg = arg\nIdle.setWaitOnly(true)\nIntr.enable()\n^^HWREG(CLKCTL_BASE + CLKCTL_O_CLKENSET0)^^ = ^CLKCTL_CLKENSET0_LGPT3\n^^HWREG(LGPT3_BASE + LGPT_O_IMSET) = LGPT_IMSET_TGT^^\n^^HWREG(LGPT3_BASE + LGPT_O_TGT)^^ = msecs * (Mcu.mclkFrequency / 1000)\n^^HWREG(LGPT3_BASE + LGPT_O_CTL) = LGPT_CTL_MODE_UP_ONCE | LGPT_CTL_C0RST^^\nend\ndef isr()\nauto fxn = curFxn\ndisable()\nfxn(curArg) if fxn\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/OneShotSysTick/","title":"OneShotSysTick","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/OneShotSysTick/#unit-oneshotsystick","title":"unit OneShotSysTick","text":"ti.mcu.cc23xx/OneShotSysTick.em<pre><code>package ti.mcu.cc23xx\nimport InterruptT { name: \"SysTick\" } as Intr\nimport Idle\nimport Mcu\nfrom em.hal import OneShotMilliI\nmodule OneShotSysTick: OneShotMilliI\nprivate:\nvar curArg: ptr_t\nvar curFxn: Handler\nfunction isr: Intr.Handler\nend\ndef em$construct()\nIntr.setHandlerH(isr)\nend\ndef em$startup()\n^^SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk^^\nend\ndef disable()\ncurFxn = null\nIdle.setWaitOnly(false)\nIntr.disable()\n^^SysTick-&gt;CTRL &amp;= ~(SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk)^^\nend\ndef enable(msecs, handler, arg)\ncurFxn = handler\ncurArg = arg\nIdle.setWaitOnly(true)\nIntr.enable()\n^^SysTick-&gt;LOAD^^ = msecs * (Mcu.mclkFrequency / 1000)\n^^SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk^^\nend\ndef isr()\nauto fxn = curFxn\ndisable()\nfxn(curArg) if fxn\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/OneShotSysTim0/","title":"OneShotSysTim0","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/OneShotSysTim0/#unit-oneshotsystim0","title":"unit OneShotSysTim0","text":"ti.mcu.cc23xx/OneShotSysTim0.em<pre><code>package ti.mcu.cc23xx\nimport InterruptT { name: \"CPUIRQ1\" } as Intr\nimport Idle\nimport Mcu\nfrom em.hal import OneShotMilliI\nmodule OneShotSysTim0: OneShotMilliI\nprivate:\nvar curArg: ptr_t\nvar curFxn: Handler\nfunction isr: Intr.Handler\nend\ndef em$construct()\nIntr.setHandlerH(isr)\nend\ndef disable()\ncurFxn = null\nIdle.setWaitOnly(false)\nIntr.disable()\n^^HWREG(SYSTIM_BASE + SYSTIM_O_ICLR) = SYSTIM_ICLR_EV0^^\nend\ndef enable(msecs, handler, arg)\ncurFxn = handler\ncurArg = arg\nIdle.setWaitOnly(true)\nIntr.clear()\nIntr.enable()\n^^HWREG(EVTSVT_BASE + EVTSVT_O_CPUIRQ1SEL) = EVTSVT_CPUIRQ1SEL_PUBID_SYSTIM0^^\n^^HWREG(SYSTIM_BASE + SYSTIM_O_IMSET) = SYSTIM_IMSET_EV0^^\nauto time1u = &lt;uint32&gt;(^^HWREG(SYSTIM_BASE + SYSTIM_O_TIME1U)^^)\nauto thresh = time1u + (msecs * 1000)\n^^HWREG(SYSTIM_BASE + SYSTIM_O_CH0CC)^^ = thresh\nprintf \"time1u = %d, thresh = %d\\n\", time1u, thresh\nend\ndef isr()\n%%[a]\nauto fxn = curFxn\ndisable()\nfxn(curArg) if fxn\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Regs/","title":"Regs","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Regs/#unit-regs","title":"unit Regs","text":"ti.mcu.cc23xx/Regs.em<pre><code>package ti.mcu.cc23xx\nmodule Regs\nend\ndef em$generateCode(prefix)\n|-&gt;&gt;&gt;\n    #include \"cmsis/cc23x0r5.h\"\n    #include \"cmsis/core/core_cm0plus.h\"\n    #include \"driverlib/hapi.h\"\n    #include \"inc/hw_memmap.h\"\n    #include \"inc/hw_types.h\"\n    #include \"inc/hw_ckmd.h\"\n    #include \"inc/hw_clkctl.h\"\n    #include \"inc/hw_evtull.h\"\n    #include \"inc/hw_evtsvt.h\"\n    #include \"inc/hw_gpio.h\"\n    #include \"inc/hw_ioc.h\"\n    #include \"inc/hw_lgpt.h\"\n    #include \"inc/hw_lgpt3.h\"\n    #include \"inc/hw_pmctl.h\"\n    #include \"inc/hw_rtc.h\"\n    #include \"inc/hw_systim.h\"\n    #include \"inc/hw_uart.h\"\n    #include \"inc/hw_vims.h\"\n    #include \"inc/hw_ccfg.h\"\n#if 0\n    extern \"C\" const ccfg_t __ccfg __attribute__((section(\".ccfg\"), used)) = {\n        .bootCfg.pBldrVtor = XCFG_BC_PBLDR_UNDEF,\n        .bootCfg.bldrParam.serialRomBldrParamStruct.bldrEnabled = XCFG_BC_BLDR_DIS,\n        .bootCfg.bldrParam.serialRomBldrParamStruct.serialIoCfgIndex = 0,\n        .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerDio = 0,\n        .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerEnabled = XCFG_BC_PINTRIG_DIS,\n        .bootCfg.bldrParam.serialRomBldrParamStruct.pinTriggerLevel = XCFG_BC_PINTRIG_LEVEL_LO,\n        .bootCfg.pAppVtor = (void*)0x0,\n        .hwOpts = {0xffffffff, 0xffffffff},\n        .permissions.allowDebugPort = CCFG_PERMISSION_ALLOW,\n        .permissions.allowEnergyTrace = CCFG_PERMISSION_ALLOW,\n        .permissions.allowFlashVerify = CCFG_PERMISSION_ALLOW,\n        .permissions.allowFlashProgram = CCFG_PERMISSION_ALLOW,\n        .permissions.allowChipErase = CCFG_PERMISSION_ALLOW,\n        .permissions.allowToolsClientMode = CCFG_PERMISSION_ALLOW,\n        .permissions.allowFakeStby = CCFG_PERMISSION_ALLOW,\n        .permissions.allowReturnToFactory = CCFG_PERMISSION_ALLOW,\n        .misc.saciTimeoutOverride = 1U,\n        .misc.saciTimeoutExp = 7,\n        .flashProt.writeEraseProt.mainSectors0_31 = 0xffffffff,\n        .flashProt.writeEraseProt.mainSectors32_255 = 0xffffffff,\n        .flashProt.writeEraseProt.ccfgSector = 0,\n        .flashProt.writeEraseProt.fcfgSector = 0,\n        .flashProt.writeEraseProt.engrSector = 0,\n        .flashProt.res = 0xFFFFFFFFU,\n        .flashProt.chipEraseRetain.mainSectors0_31 = 0x0,\n        .flashProt.chipEraseRetain.mainSectors32_255 = 0x0,\n        .debugCfg.authorization = CCFG_DBGAUTH_DBGOPEN,\n        .debugCfg.allowBldr = CCFG_DBGBLDR_ALLOW,\n        .debugCfg.pwdId = {0x01, 0x01, 0x02, 0x03, 0x05, 0x08, 0x0d, 0x15},\n        .debugCfg.pwdHash = {0x6d, 0xd7, 0xe4, 0x36, 0xeb, 0xf4, 0x31, 0xdf,\n                            0x95, 0xae, 0x15, 0xee, 0x03, 0xba, 0x8e, 0xe4,\n                            0xc4, 0xc6, 0x3f, 0xd8, 0x45, 0x3f, 0x67, 0x5e,\n                            0x74, 0xd7, 0xc2, 0x01, 0x2c, 0x90, 0x58, 0xe5},\n    };\n#else\n    extern \"C\" const uint32_t __ccfg[] __attribute__((section(\".ccfg\"), used)) = {\n        0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000,\n        0xFFFFFFFF, 0xFFFFFFFF, 0xAAAAAAAA, 0x0000000F,\n        0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x00000000, 0x00000000, 0x00000000, 0x00000000,\n        0x0000A55A, 0x03020101, 0x150D0805, 0x36E4D76D,\n        0xDF31F4EB, 0xEE15AE95, 0xE48EBA03, 0xD83FC6C4,\n        0x5E673F45, 0x01C2D774, 0xE558902C, 0x00000000,\n    };\n#endif\n|-&lt;&lt;&lt;\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Rtc/","title":"Rtc","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Rtc/#unit-rtc","title":"unit Rtc","text":"ti.mcu.cc23xx/Rtc.em<pre><code>package ti.mcu.cc23xx\nimport InterruptT { name: \"CPUIRQ0\" } as Intr\nmodule Rtc\ntype Handler: function()\nfunction disable()\nfunction enable(thresh: uint32, handler: Handler)\nfunction getMsecs(): uint32\nfunction getRaw(oSubs: uint32*): uint32\nfunction toThresh(ticks: uint32): uint32\nfunction toTicks(secs256: uint32): uint32\nprivate:\nconst MSECS_SCALAR: uint16 = 1000 / 8\nconst RES_BITS: uint8 = 20\nvar curHandler: Handler\nfunction isr: Intr.Handler\nend\ndef em$construct()\nIntr.setHandlerH(isr)\nend\ndef em$startup()\n^^HWREG(CKMD_BASE + CKMD_O_LFINCOVR)^^ = 0x80000000 + (1 &lt;&lt; RES_BITS)\n^^HWREG(RTC_BASE + RTC_O_CTL)^^ = ^RTC_CTL_RST\n^^HWREG(EVTSVT_BASE + EVTSVT_O_CPUIRQ0SEL) = EVTSVT_CPUIRQ0SEL_PUBID_AON_RTC_COMB^^\nIntr.enable()\nend\ndef disable()\ncurHandler = null\n^^HWREG(RTC_BASE + RTC_O_IMCLR)^^ = ^RTC_IMCLR_EV0\nend\ndef enable(thresh, handler)\ncurHandler = handler\n^^HWREG(RTC_BASE + RTC_O_CH0CC8U)^^ = thresh\n^^HWREG(RTC_BASE + RTC_O_IMSET)^^ = ^RTC_IMSET_EV0\nend\ndef getMsecs()\nauto ticks = &lt;uint32&gt;^^HWREG(RTC_BASE + RTC_O_TIME8U)^^\nreturn (ticks * MSECS_SCALAR) &gt;&gt; (RES_BITS - 7)\nend\ndef getRaw(oSubs)\nvar lo: uint32\nvar hi: uint32\nfor ;;\nlo = ^^HWREG(RTC_BASE + RTC_O_TIME8U)^^\nhi = ^^HWREG(RTC_BASE + RTC_O_TIME524M)^^\nbreak if lo == ^^HWREG(RTC_BASE + RTC_O_TIME8U)^^\nend\n    *oSubs = lo &lt;&lt; 16\nreturn hi\nend\ndef isr()\n^^HWREG(RTC_BASE + RTC_O_ICLR)^^ = ^RTC_ICLR_EV0\ncurHandler() if curHandler\nend\ndef toThresh(ticks)\nreturn ^^HWREG(RTC_BASE + RTC_O_TIME8U)^^ + ticks\nend\ndef toTicks(secs256)\nreturn secs256 &lt;&lt; 8\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Uptimer/","title":"Uptimer","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/Uptimer/#unit-uptimer","title":"unit Uptimer","text":"ti.mcu.cc23xx/Uptimer.em<pre><code>package ti.mcu.cc23xx\nimport Rtc\nfrom em.hal import UptimerI\nmodule Uptimer: UptimerI\nprivate:\nvar curTime: Time\nend\ndef calibrate(secs256, ticks)\n## TODO -- implement\nreturn 0\nend\ndef read()\ncurTime.secs = Rtc.getRaw(&amp;curTime.subs)\nreturn curTime\nend\ndef resetSync()\n## TODO -- implement\nend\ndef trim()\n## TODO -- implement\nreturn 0\nend\n</code></pre>"},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/WakeupTimer/","title":"WakeupTimer","text":""},{"location":"cargo/ti.cc23xx/ti.mcu.cc23xx/WakeupTimer/#unit-wakeuptimer","title":"unit WakeupTimer","text":"ti.mcu.cc23xx/WakeupTimer.em<pre><code>package ti.mcu.cc23xx\nfrom em.hal import WakeupTimerI\nimport Rtc\nmodule WakeupTimer: WakeupTimerI\nend\ndef disable()\nRtc.disable()\nend\ndef enable(secs256, handler)\nRtc.enable(secs256, &lt;Rtc.Handler&gt;handler)\nend\ndef secs256ToTicks(secs256)\nreturn secs256 &lt;&lt; 8\nend\ndef ticksToThresh(ticks)\nreturn Rtc.toThresh(ticks)\nend\ndef timeToTicks(secs, subs)\nreturn (secs &lt;&lt; 16) | (subs &gt;&gt; 16)\nend\n</code></pre>"},{"location":"intro/","title":"Why another language\u2009???","text":"<p>For the past fifty years, the C Programming Language has significantly streamlined software development for resource-constrained embedded microcontrollers [MCUs]. Already  coming into maturity by 1980, C had proven itself as a practical \u201cmedium-level\u201d language for many of the first  8\u2009/\u200916\u2009/\u200932-bit MCUs \u2013 enabling full entitlement to the underlying silicon, while offering developers greater software productivity and portability over native assembly language.</p> <p>As a testimony to its staying power, C continues to this day as the dominant programming language for resource-constrained MCUs; and given that we still write embedded software targeting  8\u2009/\u200916\u2009/\u200932-bit processors \u2013 often with less than 32K of memory \u2013 do we really have a practical alternative to C\u2009???\u00a0\u00a0  Yes, we do \u2013 EM.</p> Other embedded programming languages <p>Besides C and assembler, practitioners cite C++, Java, and Python as other languages of choice for embedded software development \u2013 with interest in Go and Rust starting to grow. For a variety of reasons, none of these languages come close to overtaking the dominant position of C:\u00a0 developers often fear a steep learning curve with a new language, offsetting any potential gain in productivity; and the language itself might introduce additional runtime overhead in time and (especially) space that render it impractical for the most resource-constrained MCUs. </p>"},{"location":"intro/#the-big-picture","title":"The big picture","text":"<p>The EM software platform comprises a novel programming language and run-time environment which targets resource-constrained embedded hardware \u2013 on the low-end, systems potentially managed by 8-bit MCUs using as little as 4\u2009K of program memory and 256\u2009B of data. Compared with C, EM features a higher-level programming paradigm centered around highly-reusable software modules which embody the principles of encapsulation, abstraction, and composition.</p> <p>At the same time, higher-level language constructs introduced by EM don't necessarily cause higher-levels of run-time overhead; modular EM applications designed using modern software techniques will often outperform comparable C programs written in a more conventional style. As you'll learn later on, the EM language translator will in fact generate monolithic C\u2009/\u2009C++ programs from a set of EM source modules \u2013 leveraging the maturity and ubiquity of optimizing C\u2009/\u2009C++compilers for embedded MCUs.</p> <p>More than a programming language, the EM platform also features a modular run-time environment (written in EM, of course\u2009!!!) which streamlines developer productivity through software re-use as well as increases application portability through abstraction \u2013 all without compromising overall system performance. The EM run-time modules include basic services which handle and dispatch real-time application events, as well as device-drivers which manage hardware peripherals typically found within embedded MCUs.</p> Write once, run anywhere <p>Not unlike other software platforms ranging from Java and Linux to Ruby and Python, EM offers up a \"write once, run anywhere\u2009...\" value-proposition for its application developers. The difference, needless to say, lies in the underlying hardware configurations targeted by EM \u2013 memory-constrained MCUs otherwise incapable of supporting Java or Linux (let alone Ruby or Python), for which C has remained the dominant programming environment for over a half-century.</p>"},{"location":"intro/#tiny-code-tiny-chips","title":"Tiny code \u2192 Tiny chips","text":"<p>EM programs typically consume less memory than their C counterparts \u2013 a critical feature when targeting resource-constrained MCUs. With 3\u2009X\u2009\u2013\u20095\u2009X reductions in program size not uncommon in practice, many real-world EM applications can comfortably fit in (say) a 32K memory space.</p> <p>The latest 32-bit MCUs deployed in edge-computing applications will often feature generous amounts of flash memory [\u2009\u2265\u2009512K\u2009] for storing program code, as well as large blocks of SRAM [\u2009\u2265\u200964K\u2009] for reading\u2009+\u2009writing program data; these MCUs also feature processors with sophisticated pipelines as well as advanced memory caches \u2013 all boosting the performance of large (and ever-growing\u2009!!!) bodies of legacy C code used in today's applications.</p> <p>But what if our EM-based applications really did require only 32\u2009K of memory\u2009???</p> <p>We could take conventional MCU designs \"over-the-edge\" by embracing a radically simple set of hardware featues which collectively would define the fringe of embedded processing:</p>  \u00a0entry-level CPU core\u00a0  \u2009 no larger than Arm Cortex-M0+  \u00a0tightly-coupled memories (TCMs)\u00a0  \u2009code\u2009+\u2009data; \u2264\u200932K per bank; zero wait-state SRAM  \u00a0bulk flash and NO cache\u00a0  \u2009TCMs loaded under firmware control  \u00a0rudimentary peripherals\u00a0  \u2009  no specialized auxiliary CPU cores  \u00a0always-on domain\u00a0  \u2009 wakeup events from deep-sleep power modes  \u00a0\u2265\u2009100MHz system clock\u00a0  \u2009no TCM wait-states \u2192 maximize CPU throughput <p>Features  through  would collectively minimize the number of logic gates and memory cells required to implement this MCU in silicon \u2013 resulting in a smaller chip die compared with a more fully-featured design, which (holding other factors constant) forecasts lower manufacturing costs as well as lower leakage power.</p> <p>To support \"sleepy applications\" with short active-duty cycles, feature  enables our MCU to execute for years on small batteries \u2013 or even indefinitely using harvested energy. Because of its relatively small die-size, our MCU could likely consume \u2264\u20091\u03bcW of power when sleeping; and by retaining all program state in the (small) TCMs of , our MCU can quickly return to its fully-powered active mode when awoken by an event.</p> <p>Feature , however, seems at odds with achieving an energy-efficient design \u2013 faster clocks proportionally increase switching (dynamic) power consumption; but since the CPU can access its TCMs without waiting, increased clock speed also results in proportionally faster software execution \u2013 enabling our duty-cycled application to spend more time in deep-sleep. In practice, this approach actually improves overall energy(1)utilization by reducing the (static) overhead of leakage power during active execution periods.</p> <ol> <li>E = \u222b\u2009 (P<sub>leakage</sub> + P<sub>switching</sub>) dt</li> </ol> <p>Given that feature  enables faster execution, the peripherals of  can now leverage software running on the main CPU core to perform functions that would otherwise require additional hardware \u2013 such as advanced encryption modes or the upper layers of a comm stack.  Unlike conventional cryto or radio blocks (which often contain their own dedicated cores) our peripherals embody a \"RISC-like\" approach which efficiently implements only rudimentary primitives in hardware and then relegates higher-levels functions to software.</p> <p>EM programs that target our MCU will often exhibit a simple, cyclic structure:</p> <p>awaken from deep-sleep</p> <p>acquire data from the environment</p> <p>analyze this data using an algorithm</p> <p>transmit results (wirelessly) to the edge</p> <p>re-enter deep-sleep</p> <p>Because of their single-threaded design, these programs would only require a single CPU core to maximize application throughput; software functions normally relegated (say) to an auxiliary cyrto or radio core can now execute exclusively on the main CPU.  Consolidating all software onto a single core not only maximizes re-use of MCU logic elements, but can further reduce cost and power by minimizing the silicon footprint of certain peripherals.(1)</p> <ol> <li>We'll return to this topic further downstream. </li> </ol> <p>So thanks to EM \u2013 10\u2009X fewer bytes, 10\u2009X fewer transistors, 10\u2009X lower power, 10\u2009X lower cost\u2009!!!</p> The promise of RISC-V <p>The emergence of RISC-V as an open instruction-set architecture has triggered an abundance of innovation in MCU design; you can literally find dozens of open-source projects containing synthesizable cores expressed in languages like Verilog and VHDL.  While much of the RISC-V community has set its sights on high-performance computing from the edge up to the cloud, some practitioners have focused on \"tiny cores\" suitable for low-power, low-cost applications on the fringe; visit the X-HEEP and NEORV32 projects as examples.</p> <p>With more degrees of freedom when implementing the entry-level RV32ICM instruction set \u2013 often compared against the ARM Cortex-M0+ \u2013 MCU designers can truly innovate when realizing our earlier feature  \u2013 all in the interest of further shrinking silicon and software:</p> <ul> <li> <p>by using an internal 8-bit or 16-bit ALU, optionally increasing  to maintain throughput;</p> </li> <li> <p>by locating  <sup>\u2013</sup>  in a compact (17-bit) address-space, further improving RV32ICM code-density; or</p> </li> <li> <p>by adding specialized instructions to accelerate higher-level software functions supporting </p> </li> </ul> <p>Here again, the tiny-code of EM serves as a catalyst which can drive novel RISC-V tiny-chips.</p>"},{"location":"intro/#technical-overview","title":"Technical overview","text":"<p>Building upon the tiny\u00a0code\u2009\u2192\u2009tiny\u00a0chips premise behind EM, let's dive into some technical details\u2026.\u00a0  The following chapters each focus on a particular aspect of the language and its runtime enviorment, and collectively provide a technical overview of the EM platform:</p> 1)\u2003 EM modules &amp; interfaces \u2014 The client/server dichotomy 2)\u2003 EM composites &amp; templates \u2014 Assembling application elements 3)\u2003 EM program life-cycle  \u2014 From build-time to run-time 4)\u2003 EM runtime bundles \u2014 Software platform content <p>We encourage you to read these chapters in sequence, as each subsequent chapter builds on material covered by its predecessors. At the same time, we recognize that this document introduces a lot of (new) information about a (new) programming environment; feel free to proceed iteratively, skimming the content on your first pass before circling back for a more thorough reading.</p> <p>The technical overivew also includes exemplary source-code fragments, written in the EM programming language and formatted as follows:</p> Hello.em<pre><code># we've omitted a few details here\n# but you should get the basic idea\nmodule Hello\nend\ndef em$run()\nprintf \"Hello world\\n\"\nend\n</code></pre> <p>Even if you don't plan to (initially) install and use EM, these fragments should give you an intuitive sense of the language \u2013 which relies upon familiar programming constructs (such as seen at line 8 above) that you've likely encountered elsewhere.</p> <p>So with that, let's move onward to Chapter 1 and begin our technical overview of EM.</p> EM's origin story <p>The EM programming language first appeared at UC Santa Barbara in 2010, where undergraduate students taking CS190C\u2009/\u2009ECE1940 would develop \u201creal-world\u201d embedded applications targeting resource-constrained MCUs \u2013 with all software written in EM, of course, using this (now outdated) language primer as a guide.</p> <p>The EM language had emerged through deep discussion and intense interaction with Amichai Amar \u2013 a UCSB PhD candidate at that time.  Consult his thesis for more details on the outcome of our undergraduate course, as well as a more comprehensive exposition of programming resource-constrained MCUs using EM.</p> <p>But the true EM backstory actually began decades before its debut at UCSB.  In 1998, Texas Instruments acquired Spectron Microsystems \u2013 whose SPOX and DSP/BIOS products had already emerged as de facto industry standards.  This milestone validated the importance of software technology in further solidifying TI's leadership as a DSP silicon vendor, and in fact triggered a flurry of similar acquisitions during the dot-com boom.</p> <p>Once inside TI, the Spectron team broadened the application of its patented configuration technology \u2013 which had already enabled DSP/BIOS to fit comfortably within the 2\u2009K boot ROM of broadly-deployed, low-power DSPs. This effort culminated in the open-source RTSC project, hosted at the Eclipse Foundation beginning in 2007 and still used today within TI software products.  But RTSC fell a bit short in fulfilling its vision \u2013 and provided some much needed impetus for the birth of EM a few years later.</p> <p>EM's coming-of-age began in 2011 with the founding of Emmoco \u2013 an early player offering an embedded\u2009\u2194\u2009mobile connectivity stack targeting new TI wireless MCUs which supported the emerging BLE standard.  Acquired by Shelfbucks in late 2015, the Emmoco stack ultimately evolved to support long-range, low-power subGHz radios in which one cloud-connected HUB can interact with (say) 10,000 TAGs in a 500,000 sq ft venue.</p> <p>After Shelfbucks ceased operations in 2019 \u2013 and thanks to some legacy licensing agreements \u2013 EM found its way onto other low-power wireless MCUs from vendors such as NXP, Analog Devices, and ON Semiconductor; EM's foray into the world of RISC-V (as detailed in an earlier note) also began in this time frame. Targeting very high-volume applications for over a decade now, EM's uncanny ability to reduce firmware footprint proved critical in keeping system size, power, and cost in check.</p> <p>As of today, EM has supported more than twenty 8\u2009/\u200916\u2009/\u200932-bit MCUs from almost a dozen silicon vendors. The EM language translator \u2013 which ultimately outputs ANSI C\u2009/\u2009C++ code for portability \u2013 has also targeted the most popular toolchains for embedded development (GCC, IAR, Keil, LLVM). Thanks to a recent rewrite of the translator into TypeScript, EM now enjoys robust language support within the VS Code IDE.</p> <p>More important, perhaps, just a handful of EM programmers have developed thousands of EM modules used (and often re-used\u2009) across a broad spectrum of IoT applications targeting these MCUs. But due to these applications' proprietary nature, the EM language and its runtime has remained closed \u2013 until now\u2009!!!</p> <p></p>"},{"location":"intro/to-1/","title":"The client/supplier dichotomy","text":"<p>EM revolves around the concept of a concrete <code>module</code>, a programmatic construct that plays a seminal role within the language comparable to the position held by a class within C++ or Java. Not unlike classes, each EM module defines a programmatic boundary between its clients \u2013 users of the module \u2013 and the supplier of the module itself.</p> <p>To minimize direct coupling between clients and suppliers \u2013 and therefore to increase software re-use \u2013 EM also supports module abstraction through an <code>interface</code> construct which clients in turn can leverage through a module <code>proxy</code>.</p>"},{"location":"intro/to-1/#source-code-structure","title":"Source-code structure","text":"<p>Reflecting a basic dichotomy between module clients and module suppliers, consider the overall organization of a sample EM module named <code>Mod1</code>, whose source code will reside in a file named <code>Mod1.em</code>:</p> bob.pkg/Mod1.em<pre><code>package bob.pkg\nmodule Mod1         # client-visible feature declarations\nconst C: ...\ntype T:  ...\nfunction f( ... )\n# etc\nprivate:            # supplier-proprietary feature declarations\nvar x: ...\nfunction g( ... )\n# etc\nend\ndef f(...)          # supplier-proprietary function definitions\n# body of 'f'\nend\ndef g(...)\n# body of 'g'\nend\n# etc...\n</code></pre> <p>Starting from the top, each EM module lives within the logical scope of a <code>package</code> which physically corresponds to a file-system directory of the same name. As in Java or Python, an EM package will generally bear a globally-unique qualified name that identifies its supplier \u2013 <code>bob.pkg</code>, <code>bob.pkg.test</code>, <code>dave.pkg</code>, and so forth. By extension, all EM modules have a (globally-unique) fully-qualified canonical name \u2013 <code>bob.pkg/Mod1</code> in the current example \u2013 though in practice you'll invariably refer to modules using simple names like <code>Mod1</code>.</p> Flat directory structure <p>But unlike Java or Python, where the contents of a package named <code>bob.pkg</code> would actually reside in a nested directory structure with the path <code>bob/pkg</code>, EM employs a flat organization in which the logical package-name and physical directory-name must match exactly.</p> <p>Moving on, the declarations beginning at line 3 comprise the public specification of this module \u2013 a coherent collection of constants, types, and functions (what others might term an \"API\"\u2009) available for direct use by clients of <code>Mod1</code>. Taken together, these externally-visible features of the module constitute a programmatic contract in which future changes on the part of the supplier should (hopefully!!!\u2009) not violate prior client assumptions.</p> <p>By contrast, features of <code>Mod1</code> declared beginning at line 9 along with all definitions of its public and private functions beginning at line 15 remain hidden from any clients of this module. The supplier of <code>Mod1</code> can consequently change the internal implementation of this module \u2013 optimizing performance or improving robustness \u2013 while maintaining a measure of \"plug-compatibility\" from its clients' perspective.</p> Separation of concerns <p>By enforcing crisp boundaries between clients and suppliers, EM modules encourage a software \"best-practice\" known as separation of concerns \u2013 organizing application functionality into discrete programmatic elements that encapsulate specific implementation decisions. Besides helping us digest software-rich systems in \"bite-sized\" chunks (where each EM module becomes a small world unto itself), our ability to manage change throughout the software life-cycle emerges as the most enduring benefit of modularity in general.</p>"},{"location":"intro/to-1/#importing-modules","title":"Importing modules","text":"<p>To gain access to public features of <code>bob.pkg/Mod1</code>, clients must explicitly <code>import</code> this module within their own\u2009<code>.em</code> files prior to any direct usage. As an illustration, consider a sample module named <code>dave.pkg/Mod2</code>:</p> dave.pkg/Mod2.em<pre><code>package dave.pkg\nfrom bob.pkg import Mod1\nmodule Mod2       # client-visible feature declarations\nfunction f( ... )\nprivate:          # supplier-proprietary feature declarations\nvar t: Mod1.T\nend\ndef f(...)        # supplier-proprietary function definitions\nMod1.f( ... )\nend\n</code></pre> <p>The directive at line 3 effectively adds the identifier <code>Mod1</code> to this file's top-level namespace, which already includes all public\u2009/\u2009private feature names of <code>Mod2</code>; an optional trailing <code>as</code> clause can resolve name conflicts, should they arise. Through their <code>import</code> directives, EM modules organize themselves into a static hierarchy of clients and suppliers. As a rule, this client-supplier relation must remain acyclic; an EM module can neither directly nor indirectly import itself.</p> <p>After importing <code>Mod1</code>, the example accesses this module's public type <code>T</code> at line 9 followed by its public function <code>f</code> at line 13 using a qualified name of the form <code>Mod1.feature</code>. This syntax enables client modules using <code>Mod1</code> to (coincidentally) declare their own features with identical names, such as the function <code>f</code> defined here within the scope of <code>Mod2</code>; unqualified identifiers always refer to features defined within the current module.</p> Main programs <p>By implementing a special (intrinsic) function named <code>em$run</code>, any EM module can potentially serve as the entry-point for an executable application \u2013 a common pattern in many modern languages. Said another way, EM has no inherent notion of a \"main-program\"; instead, application developers will designate a particular module as the top of a client-supplier hierarchy defined via <code>import</code> directives.</p>"},{"location":"intro/to-1/#abstracting-suppliers","title":"Abstracting suppliers","text":"<p>At the end of the day, EM application programs comprise a set of concrete modules \u2013 each contributing some measure of encapsulated code and data to the final executable image. In the example above, where we directly imported <code>bob.pkg/Mod1</code>, this module will auto\u00admatically and unconditionally become an element of any application program that directly or indirectly uses <code>dave.pkg/Mod2</code>.</p> <p>As an alternative to this mode of direct coupling between modules, EM introduces a language construct known as a <code>proxy</code> that adds a level of indirection between clients and suppliers \u2013 abstracting a particular supplier's identity from the client's perspective. Akin to polymorphism within object-oriented programming, EM proxies can enhance application flexibility and improve software re-use by further decoupling clients from suppliers; the same client module, as you'll soon see, can effectively (re-)use different supplier imple\u00admentations of otherwise common functionality.</p> <p>And even more important than re-use, we can better manage change\u2009!!!</p> <p>By not having to modify client modules that employ proxies, our software becomes more resilient and malleable when \u2013 and not if \u2013 application requirements evolve over time.</p> <p>To capture commonality amongst a family of \"plug-compatible\" modules, EM enables us to separately publish a set of client-visible features as an <code>interface</code> \u2013 a public specification independent of any particular supplier implementation. As an illustration, let's refactor the <code>bob.pkg/Mod1</code> module presented earlier.</p> <p>bob.pkg/ModI.em<pre><code>package bob.pkg\ninterface ModI             # public specification only  \nconst C: ...\ntype T:  ...\nfunction f( ... )\nend\n</code></pre> bob.pkg/Mod1.em<pre><code>package bob.pkg\nfrom bob.pkg import ModI\nmodule Mod1: ModI         # public specification  \n# additional features\nprivate:                  # internal implementation\n# same as before\nend\ndef f()\n# body of 'f'\nend\n# etc...\n</code></pre></p> <p>The declarations beginning at line 3 mimic the earlier public specification of <code>bob.pkg/Mod1</code>; but unlike a concrete module, an abstract EM interface cannot have an internal implementation. Our new rendition of <code>Mod1</code> now inherits its public specification from the interface <code>ModI</code> at line 3, while declaring any additional (public) features unique to this module; the private portion of <code>Mod1</code> beginning at line 8 remains unchanged from before.</p> More on interfaces <p>In practice, abstract interfaces and implementing modules will often reside in different packages:  for instance, the EM runtime contains a package named  em.hal holding <code>ConsoleUartI</code>, <code>GpioI</code>, <code>WakeupTimerI</code>, and other interfaces; packages such as  ti.mcu.cc23xx then hold concrete implementations of these abstract interfaces targeting a particular MCU architecture.</p> <p>Returning to the matter at hand \u2013 abstracting suppliers \u2013 we'll now refactor our original <code>dave.pkg/Mod2</code> client module to remove its direct dependence on <code>bob.pkg/Mod1</code> and instead leverage a local <code>proxy</code> implementing the <code>ModI</code> interface.</p> dave.pkg/Mod2.em<pre><code>package dave.pkg\nfrom bob.pkg import ModI\nmodule Mod2       # client-visible feature declarations\nproxy ModX: ModI\nfunction f( ... )\nprivate:          # supplier-proprietary feature declarations\nvar t: ModX.T\nend\ndef f(...)        # supplier-proprietary function definitions\nModX.f( ... )\nend\n</code></pre> <p>The syntax at line 6 adds the name <code>ModX</code> to the top-level scope of <code>Mod2</code>, as well as declares that the proxy <code>ModX</code> provides all client features specified within the interface <code>ModI</code>; access to the public type <code>T</code> and the public function <code>f</code> at lines 10 and 14 respectively mirror earlier direct usage of <code>bob.pkg/Mod1</code>.</p> <p>Once again, we should emphasize that client <code>Mod2</code> has no overt coupling to the concrete module <code>Mod1</code>; instead, <code>Mod2</code> only knows about the abstract interface <code>ModI</code> \u2013 which would admit an unbounded number of alternate implementations beyond that provided by <code>Mod1</code>.</p> The proxy\u2009\u2013\u2009interface pattern <p>The pattern exemplified here occurs extensively within the EM runtime, and largely holds the key to maintaining platform portability. As a case in point, the package  em.utils contains only portable modules such as <code>AlarmMgr</code> which declares a local proxy implementing the  em.hal/WakeupTimerI interface. Client application modules likewise desiring hardware independence can simply follow suit, using the <code>proxy</code>\u2009\u2013\u2009<code>interface</code> pattern at each point of potential variability.</p> <p>Moving on to Chapter 2, we'll now explore the process of binding  the <code>Mod2</code><code>.</code><code>ModX</code> proxy to the <code>Mod1</code> module.</p> <p></p>"},{"location":"intro/to-2/","title":"Assembling application elements","text":"<p>By leveraging the <code>proxy</code>\u2009\u2013\u2009<code>interface</code> design pattern, EM modules exhibit component-like qualities \u2013 enabling third-party integrators to effectively compose a set of modules that otherwise have no direct knowledge of one another.</p> <p>To facilitate general aggregation and assembly of discrete modules into larger application entities, the EM language introduces a multi-faceted construct known as a <code>composite</code> to service these needs.</p>"},{"location":"intro/to-2/#aggregating-modules","title":"Aggregating modules","text":"<p>Like modules and interfaces, each EM composite resides under a named package and will import other units \u2013 modules, interfaces, even composites \u2013 into its top-level namespace. Consistent with their role as higher-level collection points for discrete modules, EM composites will often import surprisingly large numbers of modules in practice.(1)</p> <ol> <li> ti.distro.cc23xx/McuC for example</li> </ol> <p>In their most elementary form, EM composites will selectively <code>export</code> a group of concrete modules under logical names known to higher-level clients.</p> bob.pkg/CompC.em<pre><code>package bob.pkg\nimport Mod1 as ModX     # omit redundant 'from' clause\nexport ModX             # a logical module\ncomposite CompC             end\n</code></pre> <p>After re-labeling <code>bob.pkg/Mod1</code> at line 3 using an <code>as</code> clause, the <code>export</code> directive at line 5 publicizes the name <code>ModX</code>; clients importing <code>CompC</code> can then use the (logical) module named <code>ModX</code>, otherwise oblivious to its true identity as <code>bob.pkg/Mod1</code>. While not declared explicitly, <code>ModX</code> in fact belongs to the <code>ModI</code> family of modules \u2013 serving as a concrete delegate suitable for binding to an abstract proxy implementing a common programmatic interface.</p> Component-oriented programming <p>Programming with components \u2013 which takes modularity, separation of concerns, and resilience in the face of change to entirely new levels \u2013 dictates that (abstract) interfaces define all functional interactions between independently-replaceable elements. As such, each (concrete) software component \"provides\" and \"requires\" services defined by some set of interfaces \u2013 not unlike the standardized \"plugs\" and \"sockets\" found in hardware components. Through disciplined use of <code>export</code> directives within EM composites and <code>proxy</code> declarations within EM modules, we can emulate the provides\u2009\u2013\u2009requires paradigm that forms the backbone of all component-oriented systems.</p>"},{"location":"intro/to-2/#binding-proxies","title":"Binding proxies","text":"<p>Besides aggregating modules, EM composites will often take on the task of \"wiring\" together a set of modules into a more integrated assembly \u2013 especially modules like our last version of <code>dave.pkg/Mod2</code>, which utilize local proxies to further decouple themselves from potential suppliers. To illustrate:</p> geof.pkg/CompC.em<pre><code>package geof.pkg\nfrom bob.pkg import Mod1      # concrete delegate\nfrom dave.pkg import Mod2     # exposes abstract proxy\ncomposite CompC\n# no features\nend\ndef em$configure()\nMod2.ModX ?= Mod1         # bind proxy to its delegate\nend\n</code></pre> <p>Reflecting its higher-level position within the application hierarchy, this particular composite reaches across multiple packages starting at line 3 when importing a set of modules. The actual binding of <code>bob.pkg/Mod1</code> to <code>dave.pkg/Mod2</code> via the latter's <code>ModX</code> proxy then occurs at line 11, using a special single-assignment operator [\u2009<code>?=</code>\u2009] which we'll explain later. We'll also have more to say about the role played by the intrinsic function <code>em$configure</code>.</p> EM distro packages <p>To use the EM language, you'll need an EM distro \u2013 a multi-tiered sub-system that melds portable runtime content in packages like <code>em.utils</code> with hardware-specific content in packages like <code>ti.mcu.cc23xx</code>. By design, each EM distro will publish a top-level composite with a fully-qualified name like  ti.distro.cc23xx/BoardC. This <code>BoardC</code> composite in turn builds upon other composites \u2013 whether hardware-specific  ti.distro.cc23xx/McuC or else portable  em.mcu/CommonC.</p>"},{"location":"intro/to-2/#configuring-parameters","title":"Configuring parameters","text":"<p>Just as individual functions may have parameters, EM modules as a whole can publicize a special kind of parameter known as a <code>config</code> which clients in turn can selectively assign inside of <code>em$configure</code>. To illustrate typical usage, let's expand our earlier versions of <code>bob.pkg/Mod1</code> and <code>dave.pkg2/Mod2</code> to now expose some new client-visible features in the form of configuration parameters.</p> bob.pkg/Mod1.em<pre><code>package bob.pkg\nmodule Mod1\nconfig flag: bool\n#   ^| Enable some functionality\n# other public features\nprivate:\n# etc...\n</code></pre> dave.pkg/Mod2.em<pre><code>package dave.pkg\nmodule Mod2\nconfig count: uint8\n#   ^| Establish some threshold\n# other public features\nprivate:\n# etc...\n</code></pre> <p>As you might glean from the special documentation comments, the <code>flag</code> parameter declared at <code>Mod1</code> 6 and the <code>count</code> parameter declared at <code>Mod2</code> 6 should each render these modules more flexible than before, and hence increase opportunities for clients to (re-)use <code>Mod1</code> and <code>Mod2</code> in a wider range of applications. Syntactically similar to <code>const</code> and <code>var</code> declarations within the language, <code>config</code> parameters have a very special semantic property:</p> <p>An EM <code>config</code> behaves like an assignable <code>var</code> at build-time, but like a read-only <code>const</code> at run-time.</p> <p>Once we delve into the EM program life-cycle \u2013 from build-time through run-time \u2013 you'll understand the rationale behind this paradox, as well as more fully appreciate the implications of module configuration for resource-constrained embedded applications. For now, suffice it to say that EM composites serve as an ideal site for assigning module <code>config</code> parameters when assembling application programs.  Expanding our earlier example:</p> geof.pkg/CompC.em<pre><code>package geof.pkg\nfrom bob.pkg import Mod1\nfrom dave.pkg import Mod2\ncomposite CompC\nend\ndef em$configure()\nMod2.ModX ?= Mod1         # bind proxy to its delegate\nMod1.flag ?= true         # assign config parameters\nMod2.count ?= 100\nend\n</code></pre> <p>Just as we bound proxies to delegates, the single-assignment statements at lines 12 and 13 bind parameter values consistent with the types used in corresponding <code>config</code> declarations found at <code>Mod1</code> 6 and <code>Mod2</code> 6. In this light, clients can treat proxies as a special kind of con\u00adfiguration parameter \u2013 assigned <code>module</code> values implementing a declared <code>interface</code> type.</p> More configuration examples <p>The <code>em$preconfigure</code> and <code>em$configure</code> functions defined within  McuC provide a realistic example of configuration \u2013 starting with a call to <code>BoardInfo.readRecordH</code>, which returns a data-structure of board-specific parameter values read from a YAML source file. The (portable) implementation of <code>readRecordH</code> found within the  em.utils/BoardInfo module hints at the range of programmability we can bring to bear during configuration. </p>"},{"location":"intro/to-2/#instantiating-templates","title":"Instantiating templates","text":"<p>The EM language provides a general-purpose <code>template</code> mechanism for synthesizing other source-level artifacts \u2013 from fragments of C code to complete\u2009<code>.em</code> files \u2013 during the program build process. The latter scenario, which we'll focus on here, enables suppliers to deliver concrete modules in a more generic embodiment \u2013 one that clients will frequently instantiate within the context of an EM composite.</p> <p>Starting from the client's perspective, the following composite effectively manufactures a pair of new modules \u2013 locally aliased as <code>Clone1</code> and <code>Clone2</code> \u2013 by instantiating a common imported template named <code>thom.pkg/GenT</code>.</p> geof.pkg/CompC.em<pre><code>package geof.pkg\nfrom thom.pkg import GenT {flag: true, count: 100} as Clone1\nfrom thom.pkg import GenT {flag: false, count: 200} as Clone2\nexport Clone1\nexport Clone2\ncomposite CompC\nend\ndef em$configure()\n# assign Clone&lt;n&gt; config parameters\n# bind Clone&lt;n&gt; proxies to delegates\n# delegate other proxies to Clone&lt;n&gt;\nend\n</code></pre> <p>Using an expanded form of <code>import</code> directive at lines 3 and 4, this composite works with (synthesized) modules <code>Clone1</code> and <code>Clone2</code> no differently than how we employed the <code>bob.pkg/Mod1</code> or <code>dave.pkg/Mod2</code> modules defined earlier. Since <code>Clone1</code> and <code>Clone2</code> have no prior outside identity, composites will often <code>export</code> these newly-formed modules for use by higher-level clients; composites may further configure and assemble these synthesized modules within the body of their own <code>em$configure</code> function.</p> <p>The <code>flag</code> and <code>count</code> values bound at lines at lines 3 and 4 above \u2013 which shape the essential characteristics of the synthesized <code>Clone1</code> and <code>Clone2</code> modules \u2013 ultimately correspond to public configuration parameters declared within <code>thom.pkg/GenT</code>:</p> thom.pkg/GenT.em<pre><code>package thom.pkg\ntemplate GenT\nconfig flag: bool\n#   ^| Enable some functionality\nconfig count: uint8\n#   ^| Establish some threshold\nend\ndef em$generateUnit(pn, un)\n            |-&gt; package `pn`\n            |-&gt;\n            |-&gt; module `un`\n            |-&gt;\nif flag\n            |-&gt; const MAX: Uint8 = `count`\nend\n# generate remainder of this module\nend\n</code></pre> <p>Like any other <code>config</code>, the parameters declared after line 5 become assignable variables at program build-time \u2013 in this case, via <code>import</code> directives beginning at line 3 of <code>CompC</code>. The <code>GenT</code> template will then consume these configuration parameters within the body of its <code>em$generateUnit</code> function, which synthesizes lines of source code using special EM output statements prefixed by the <code>|-&gt;</code> symbol.</p> <p>The <code>flag</code> config declared at 6 impacts the generated output by controlling execution flow within <code>em$generateUnit</code>; by contrast, this function directly interpolates the <code>count</code> config declared at 9 within the generated output. When invoked, <code>em$generateUnit</code> receives <code>pn</code> and <code>un</code> arguments bound to strings like <code>\"geof.pkg\"</code> and <code>\"CompC__Clone1\"</code> \u2013 reflecting the original context in which the <code>geof.pkg/CompC</code> composite imported and instantiated the <code>GenT</code> template back on the earlier line 3.</p> More template examples <p>Our  McuC composite instantiates a module-per-pin using this  GpioT template. Inspecting this template's <code>em$generateUnit</code> function, note how the <code>pin</code> config ultimately shapes the synthesized module through interpolation within the <code>|-&gt;</code> output statements. Though not a rule, synthesized modules will often implement an interface that captures their commonality \u2013  em.hal/GpioI in the example at hand.</p> <p>To further grasp the special role played by <code>composite</code> and <code>template</code> units, let's proceed onward to Chapter 3 and explore EM's rather unique build flow.</p> <p></p>"},{"location":"intro/to-3/","title":"From build-time to run-time","text":"<p>We turn now to the life-cycle of an EM program \u2013 covering its build-time transformation from a single \"main\" source module into a binary program image comprising multiple modules, as well as its run-time execution phases from hardware reset to system shutdown.</p> <p>Along the way, you'll understand the role played by EM language intrinsics throughout the program life-cycle \u2013 not only to demarcate execution phases at program run-time (<code>em$run</code>), but also to enable active participation by content suppliers at various stages during program build-time (<code>em$configure</code> and <code>em$generateUnit</code>).</p>"},{"location":"intro/to-3/#high-level-build-flow","title":"High-level build flow","text":"<p>The following figure depicts the four principal phases of the EM program life-cycle, as well as maps out the high-level flow of build-time artifacts \u2013 starting with a <code>ModP.em</code> source file and ending with a <code>main.out</code> binary image. The first three of these phases unfold on your host computer, and collectively constitute program build-time; the final phase, needless to say, represents run-time execution of the generated program on target hardware. </p> <p></p> Program build flow"},{"location":"intro/to-3/#unit-translation","title":"Unit translation","text":"<p>Each\u2009<code>.em</code> source file \u2013 whether a <code>module</code>, <code>interface</code>, <code>composite</code>, or <code>template</code> \u2013 represents an independent unit of translation within EM. Starting from a designated top-level unit \u2013 in our case, a module named <code>ModP</code> which would implement the <code>em$run</code> intrinsic \u2013 EM will (recursively) process an N-element hierarchy of other translation units that <code>ModP</code> directly or indirectly imports; since the relation defined by <code>import</code> directives cannot have cycles, translating <code>ModP</code> effectively yields a top-to-bottom (partial) ordering of its dependent units.</p> <p>Translating concrete modules such as <code>ModP</code> will generally produce three corresponding output files, consumed in subsequent phases of the program build process:</p> <code>ModP.hpp</code> the public\u2009/\u2009private features of <code>ModP</code> translated into a C++ header file <code>ModP.cpp</code> internal function definitions within <code>ModP</code> translated into equivalent C++ code <code>ModP.js</code> a JavaScript rendition of <code>ModP</code> which will contribute during program configuration <p>Translating abstract interfaces such as our earlier <code>ModI</code> example will only yield a <code>ModI.js</code> and <code>ModI.hpp</code> output file.  Translating composites or templates such as our earlier <code>CompC</code> or <code>GenT</code> examples \u2013 which contribute at build-time but not run-time \u2013 will only yield a <code>CompC.js</code> or <code>GenT.js</code> output file.</p> <p>Finally, all template instantiations encountered en route through <code>import</code> directives (such as the references to <code>GenT</code> in <code>CompC</code>) will trigger immediate execution of the designated template's <code>em$generateUnit</code> intrinsic \u2013 already translated to JavaScript within the <code>GenT.js</code> output file. Unit translation of the new\u2009<code>.em</code> file produced at this step then proceeds recursively.</p> Translator efficiency <p>A top-level module such as <code>ModP</code> could easily have static dependencies on more than 100 other translation units \u2013 especially when imported composites aggressively instantiate templates managing discrete MCU resources like GPIO pins. To accelerate program build-time, the EM translator maintains an internal cache of all generated files and will only (re-)translate a particular\u2009<code>.em</code> file when deemed necessary.</p>"},{"location":"intro/to-3/#program-configuration","title":"Program configuration","text":"<p>The configuration phase of the EM program life-cycle \u2013 still upstream from the final compilation of all generated C++ code into a binary image \u2013 actually entails executing a special hosted version of the program rendered in JavaScript. Labeled <code>main.js</code> in the earlier figure, this fabricated program basically amalgamates the\u2009<code>.js</code> files output for each module or composite found within the N-element <code>import</code> hierarchy rooted at <code>ModP</code> itself.</p> But why JavaScript\u2009??? <p>Seemingly, any hosted language (Java, Python, Ruby) could provide a suitable execution environment for this phase of the EM program life-cycle.  Some might argue the case for Python, as this language already plays a similar role with respect to C\u2009/\u2009C++ code \u2013 especially in emerging platforms such as TinyML, which deploy machine-learning algorithms (developed in a hosted Python environment) onto embedded target hardware.</p> <p>As it turns out, JavaScript had already claimed the host language role among EM's predecessors \u2013 notably the Eclipse\u2009/\u2009RTSC project which in turn drew upon earlier DSP/BIOS configuration technology. Given the Java-centricity of the Eclipse IDE, Mozilla's Rhino \u2013 a JavaScript engine written in Java and seemlessly integrated with the JVM runtime \u2013 served as an ideal environment at that point in time.</p> <p>Indeed, an Eclipse plug-in (written in Java) provided almost a decade of IDE support for the EM language; and Rhino therefore remained our JavaScript platform of choice.  But now that language support for EM has migrated to the VS Code IDE \u2013 written in TypeScript and running on the Chromium\u2009/\u2009V8 engine \u2013 Node.js provides an even richer JavaScript platform for hosting the configuration phase of the EM program life-cycle. </p> <p>During its execution, the <code>prog.js</code> program makes three top-to-bottom passes over the N-element <code>import</code> hierarchy rooted in <code>ModP</code> \u2013 invoking JavaScript translations of certain EM intrinsics on a per-unit basis (if defined).</p> <p>The 1<sup>st</sup> pass invokes <code>em$preconfigure</code>, which only composites may elect to define; public proxies and config parameters bound at this time using the single-assignment operator [\u2009<code>?=</code>\u2009] become immune to further modification in the next pass.</p> <p>The 2<sup>nd</sup> pass invokes <code>em$configure</code>, which modules as well as composites may elect to define; proxies and configs bound here using the [\u2009<code>?=</code>\u2009] operator become immune to further modification by lower-level units yet to execute in this pass.</p> <p>The 3<sup>rd</sup> pass invokes two intrinsics on modules whose special <code>em$used</code> config parameter tests true:  <code>em$construct</code>, for initializing private module state; and <code>em$generateCode</code>, for synthesizing internal C\u2009/\u2009C++ code using the EM template mechanism illustrated in <code>GenT</code>.</p> <p>The [\u2009<code>?=</code>\u2009] operator, as hinted earlier, implements single-assignment semantics \u2013 sealing the first value assigned to a configurable proxy or parameter, while silently ignoring all sub\u00adsequent assignments to the same feature. With a top-to-bottom ordering imposed on the <code>ModP</code> <code>import</code> hierarchy, [\u2009<code>?=</code>\u2009] operations executed by higher-level modules and composites essentially \"override\" (default) binding decisions made by lower-level units. By implementing <code>em$configure</code>, <code>ModP</code> itself can now preempt proxy\u2009/\u2009parameter assignments otherwise made by any modules or composites it may import.</p> More on pre-configuration <p>Higher-level modules such as <code>ModP</code> cannot, however, effect the values of configurable features already bound in the first configuration pass via <code>em$preconfigure</code>; the latter intrinsic enables suppliers of EM composites to selectively freeze proxy bindings and parameter values, tempering flexibility in the interest of robustly assembling elements for a fixed application setting. As an example, our  McuC composite binds physical pin numbers read from a board-specific YAML file \u2013 reflecting the \"hard reality\" of the underlying hardware.</p> <p>Referring to the earlier figure, one practical consequence of configuration becomes pruning the original (and often large) N\u2013element <code>import</code> hierarchy into a more tractable M\u2013element subset comprising those modules actually used within the program. In support, each module has an intrinsic <code>em$used</code> parameter \u2013 automatically bound in most cases, but explicitly con\u00adfigurable if necessary \u2013 that ultimately determines membership in the M\u2013element subset.</p> <p>The top-level module <code>ModP</code> has its <code>em$used</code> parameter automatically set, and is always used within the program.</p> <p>If module <code>Mod1</code> is used and <code>Mod1</code> imports module <code>Mod2</code> (directly or via a composite), then <code>Mod2</code> is used as well.</p> <p>If module <code>Mod1</code> is used and proxy <code>Mod1.ModX</code> ultimately delegates to module <code>Mod2</code>, then <code>Mod2</code> is used as well.</p> <p>Otherwise <code>Mod1</code> is not used in the program, unless some higher-level module or composite explicitly sets <code>Mod1.em$used</code>.</p> <p>The final configuration pass gives each used module within the M\u2013element subset an opportunity to focus internally; configuration of all public features of these modules would have already occurred. By defining the <code>em$construct</code> intrinsic, modules may programmatically initialize their private <code>var</code>, <code>config</code>, or even <code>proxy</code> features at this point within the flow.</p> <p>But since <code>em$construct</code> actually executes on your host computer, module suppliers can now implement complex initialization algorithms at build-time that would otherwise prove far too costly to execute at run-time on resource-constrained MCUs.</p> <p>With language constructs normally used to implement target-side functions like <code>em$run</code> also available in hosted functions like <code>em$construct</code>, module suppliers can now migrate (expensive) computations from run-time to build-time with little effort. Said another way, EM can serve as its own meta-language \u2013 synthesizing the final form of a concrete module by statically reflecting upon values assigned to its configurable parameters.</p> Examples of EM meta-programming \u2013 data initialization <p>The <code>em$construct</code> function of  ti.mcu.cc23xx/ConsoleUart0 computes values for private configs <code>ibrd</code> and <code>fbrd</code>, eventually used to initialize hardware registers defining the UART's baud-rate; a less efficient implementation would perform this computation at run-time.  Taking this approach to the next level, the <code>em$construct</code> function of  em.utils/FftC32 initializes a custom sine-wave table at build-time.</p> <p>Besides executing (costly) math functions, EM meta-programming can also initialize complex, linked data-structures at build-time \u2013 such as the <code>em$construct</code> function and <code>createH</code> functions of  em.utils/FiberMgr, which in turn call build-time functions of  em.utils/ListMgr.  As a general rule, any static initialization of data at build-time results in more compact programs at run-time.</p> <p>Complementing <code>em$construct</code> \u2013 oriented towards initializing private state \u2013 some modules will also implement the <code>em$generateCode</code> intrinsic. Using the same form of templatized output statements illustrated earlier in <code>GenT</code>, module suppliers can inject customized C\u2009/\u2009C++ code fragments into the final program image \u2013 with public config par\u00adameters typically shaping the synthesized output.</p> Examples of EM meta-programming \u2013 code generation <p>On the low end of the scale, MCU-specific modules like  ti.mcu.cc23xx/Regs use the <code>em$generateCode</code> intrinsic to <code>#include</code> vendor-supplied header files; modules such as  Rtc will then reference symbols and macros defined in these headers using a special <code>^^</code> escape token.</p> <p>Moving up a notch, the  ti.mcu.cc23xx/IntrVec module programmatically synthesizes the run-time vector table for this MCU using build-time bindings of interrupt handlers \u2013 complete with compiler-specific directives to control placement in memory. In the limit, <code>em$generateCode</code> can leverage the full capabilities of JavaScript executing on your host computer.</p>"},{"location":"intro/to-3/#program-compilation","title":"Program compilation","text":"<p>Referring back to the earlier figure, the ultimate outcome of executing the <code>main.js</code> (meta-) program within the overall EM build-flow becomes yet another program \u2013 this time, a single C++ program labeled <code>main.cpp</code>. As suggested earlier, this program only incorporates generated code from the M used modules selected from the original set of N imported units traced back to <code>ModP.em</code>.</p> <p>Each module <code>Mod</code> participating in this consolidated C++ program respectively contributes (in order) the following portions of code, which collectively represents the bulk of the generated <code>main.cpp</code> file's content:</p> <p>constant, type, variable, and function declarations from <code>Mod.hpp</code>, generated during the initial translation of <code>Mod.em</code>;</p> <p>static data initializers reflecting the values assigned to public\u2009/\u2009private features of <code>Mod</code> during the prior configuration phase;</p> <p>any C\u2009/\u2009C++ code synthesized by the <code>Mod.em$generateCode</code> intrinsic, executed during the prior configuration phase; and</p> <p>definitions of declared and intrinsic functions from <code>Mod.cpp</code>, generated during the initial translation of <code>Mod.em</code>.</p> <p>By merging all generated C\u2009/\u2009C++ code into a single input file, the underlying compiler for the target MCU can aggressively optimize the program as a whole \u2013 folding away constants, inlining small functions, and eliminating unused code or data. As a case in point, client function calls via abstract proxies to configured delegate modules \u2013 seemingly a double-indirection at run-time \u2013 will usually \"melt-away\" and leave the delegate function body inlined at the client call-site.</p> Example of whole-program optimization <p>Returning to  FftC32, its <code>exec</code> function uses three <code>config</code> parameters at run-time which <code>em$construct</code> previously initialized by at build-time \u2013 <code>N_WAVE</code>, <code>N_WAVE_LOG2</code>, <code>SINE_WAVE</code>.  Knowing the values of these parameters when digesting <code>main.cpp</code>, the compiler has greater latitude in making time\u2009/\u2009space tradeoffs when generating object code for <code>FftC32.exec</code>.</p> <p>As another example,  em.utils/FiberMgr makes many function calls via <code>Common.GlobalInterrupts</code> \u2013 a proxy which conforms to the  GlobalInterruptsI interface, and ultimately delegates to a hardware-specific implementation such as  ti.cc23xx.mcu/GlobalInterrupts.  Knowing this particular proxy\u2009-\u2009delegate binding, the compiler would inline the delegate's (small) functions directly at each <code>Common.GlobalInterrupts</code> call site.</p>"},{"location":"intro/to-3/#program-execution","title":"Program execution","text":"<p>This final phase of the EM program life-cycle \u2013 which represents the transition from build-time to run-time \u2013 technically commences when you load the executable <code>main.out</code> image into target memory and reset the MCU. But as you'll see, run-time contributions from the M concrete modules used within this program won't occur until execution reaches <code>main</code>.</p> The path to <code>main</code> <p>The path actually taken from loading the <code>main.out</code> file to executing the C\u2009/\u2009C++ <code>main</code> function can vary widely from one target environment [MCU\u2009+\u2009compiler\u2009+\u2009board] to the next; but fortunately, each distribution of the EM software platform will render this process transparent to the application developer. In practice, each EM distro will leverage much of the tooling infrastructure supporting the underlying MCU \u2013 from flash loaders that operate on standard\u2009<code>.bin</code> or\u2009<code>.hex</code> files, to compiler startup files like <code>crt0.s</code> that manage the transition from MCU reset to C\u2009/\u2009C++ <code>main</code> as efficiently as possible.</p> <p>For the M concrete modules bound within the <code>main.out</code> image, program run-time actually begins when target execution reaches the C\u2009/\u2009C++ <code>main</code> function. Since the un\u00adderlying compiler's own startup file does little more than prepare data memory and initialize critical CPU registers, more comprehensive startup of the target board and the MCU peri\u00adpherals still needs to occur prior to calling the top-level <code>ModP.em$run</code> intrinsic.</p> <p>The <code>main</code> function initially calls a C++ rendition of <code>Mod<sub>r</sub>.em$reset</code>, where <code>Mod<sub>r</sub></code> represents the first module to implement this intrinsic found by a top-to-bottom scan of the M modules used in this program; needless to say, this scan occurs at program build-time, not run-time. In practice, some target-specific module included with your EM distribution will assume responsibility for defining the <code>em$reset</code> intrinsic; higher-level application modules generally avoid (re-)defining this intrinsic.</p> <p>The <code>main</code> function will next call C++ renditions of <code>Mod<sub>i</sub>.em$startup</code> for each <code>Mod<sub>i</sub></code> found to implement this intrinsic; here too, a top-to-bottom scan of all M program modules occurs at build-time. Unlike <code>em$reset</code>, higher-level application modules down to target-specific driver modules will define this intrinsic in order to perform (run-time) initializations not possible during (build-time) execution of <code>em$construct</code>.</p> <p>The <code>main</code> function then calls a C++ rendition of <code>Mod<sub>s</sub>.em$startupDone</code>, where <code>Mod<sub>s</sub></code> represents the first module found to implement this intrinsic through a top-to-bottom scan of all M modules participating in the program. As with <code>em$reset</code>, your EM distribution will usually take responsibility for defining <code>em$startupDone</code> \u2013 which performs any final hardware setup before the application program assumes control.</p> <p>The <code>main</code> function finally calls a C++ rendition of <code>ModP.em$run</code>, which effectively transfers control to the top-level module of this application. Since embedded applications often execute some form of \"run forever\" loop \u2013 whether explicitly coded within the program or else implicitly managed by some run-time task scheduler \u2013 in practice the <code>em$run</code> intrinsic will not return control back to the calling <code>main</code> function.</p> Examples of <code>em$startup</code> <p>Many modules that manage MCU hardware peripherals will define <code>em$startup</code> \u2013 such as  Idle and  Rtc found in the <code>ti.mcu.cc23xx</code> package; clearly, this sort of hardware setup must occur at run-time. By extension, portable modules like  em.utils/SoftUart which leverage proxies to interact with underlying hardware may likewise rely upon <code>em$startup</code> to perform some run-time initialization \u2013 in this case, initializing a  GpioI proxy named <code>TxPin</code>.</p> <p>Should the top-level <code>ModP.em$run</code> intrinsic actually return to <code>main</code>, control then transfers to a distinguished <code>__halt</code> function \u2013 also generated prior to program compilation \u2013 which supervises an orderly shutdown of the target application. If necessary, any program module can explicitly initiate the shutdown sequence at run-time through a special <code>halt</code> statement that can appear inside EM function definitions.</p> <p>The <code>__halt</code> function will first call C++ renditions of <code>Mod<sub>i</sub>.em$shutdown</code> for each <code>Mod<sub>i</sub></code> found to implement this intrinsic; higher-level applications down to target-specific drivers modules will define this intrinsic in order to perform run-time finalization prior to halting the processor.</p> <p>The <code>__halt</code> function then calls a C++ rendition of <code>Mod<sub>h</sub>.em$halt</code>, where <code>Mod<sub>h</sub></code> represents the first module to implement this intrinsic found by a top-to-bottom scan; each EM distro offers a \"default\" version of <code>em$halt</code>, though higher-level modules may (re-)define this intrinsic in some cases.</p> <p>Should the implementation of <code>em$halt</code> happen to return to <code>__halt</code>, program control would fall-through to a special block of code that simply spins within an infinite loop.</p> <p>In cases where something goes \"seriously wrong\" within the system and execution should terminate more abruptly, EM also supports a special <code>fail</code> statement that can appear in any function definition. When executed at run-time, <code>fail</code> immediately transfers control to an implementation of the <code>em$fail</code> intrinsic \u2013 often found within the same module implementing <code>em$halt</code>; should <code>em$fail</code> return, the program likewise enters an infinite loop.</p> More on startup/shutdown intrinsics <p>By design, each EM distro relies upon the portable  em.utils/BoardController module which centralizes definitions of the singleton intrinsics <code>em$reset</code>, <code>em$startupDone</code>, <code>em$halt</code>, and <code>em$fail</code>; configuration of the <code>BoardController</code> module and its dependents typically occurs within the distro's  BoardC composite. In those (rare) circumstances where some higher-level module needs to \"override\" one of these special functions, the higher-level intrinsic definition would likely call the corresponding \"base\" function within <code>BoardController</code>.</p> <p>While we've already directed you to browse selected\u2009<code>.em</code> source files drawn from EM platform runtime, Chapter 4 concludes our technical overview with more comprehensive picture of this environment.</p> <p></p>"},{"location":"intro/to-4/","title":"Software platform content","text":"<p>While software design and development focuses on individual\u2009<code>.em</code> files \u2013 modules, interfaces, composites, templates \u2013 a more coarse-grained construct known as a bundle serves as the unit of software delivery within the EM platform. Like the packages they ultimately contain, each EM bundle bears a globally-unique qualified name suggestive of its publisher and purpose \u2013 though individual\u2009<code>.em</code> files will only reference packages by name, and never the containing bundle itself.</p> <p>Representing \"components-in-the-large\", an EM bundle will not only publicize the elements it provides but will also identify other bundles it requires for successful deployment; de\u00adpendent bundles may in turn require other bundles \u2013 reminiscent of the hierarchic <code>import</code> relation between individual\u2009<code>.em</code> files. Bundles can also serve as a unit of software versioning within the platform, with dependencies optionally constrained to particular labeled releases.</p> <p>In the sections that follow, we'll respectively explore these three EM bundles:</p> em.core <p>hardware-independent packages fundamental to EM</p> ti.cc23xx <p>hardware-dependent packages comprising a typical EM distro</p> em.docs <p>hardware-independent example programs which use the prior bundles</p>"},{"location":"intro/to-4/#portable-content","title":"Portable content","text":"<p>As its name suggests, the <code>em.core</code> bundle incorporates rudimentary and essential content present in all distributions of the EM software platform \u2013 some of which we've already visited earlier in this document. Through aggressive use of the <code>proxy</code>\u2009\u2013\u2009<code>interface</code> pattern, a critical subset of the <code>em.core</code> bundle \u2013 specifically, its <code>em.mcu</code> and <code>em.utils</code> packages \u2013 in fact remain 100% portable across all target environments.</p> em.hal <p>This package contains abstract interfaces reflecting the functionality of low-level hardware elements found within embedded MCUs \u2013 <code>ConsoleUartI</code>, <code>LedI</code>, <code>WakeupTimerI</code>, and many others; this package contains also contains \"empty\" implementations of these interfaces (<code>ConsoleUartN</code>, <code>LedN</code>, etc), often used as default <code>proxy</code> bindings. As such, this package serves as a critical hardware abstraction layer (HAL) \u2013 prescribing a fundamental architectural boundary that insulates portable (hardware-independent) content from target-specific (hardware-dependent) content.</p> em.utils <p>This package comprises a somewhat eclectic (and ever-expanding) collection of run-time application services \u2013 ranging from elementary modules like <code>ListMgr</code> and <code>FiberMgr</code> up to more sophisticated templates like <code>ButtonT</code> and <code>LedT</code>.  While mostly supporting program run-time, special <code>host</code> modules like <code>BoardInfo</code> and <code>BoardMeta</code> offer (portable) services used by EM distros at program build-time.</p> em.mcu <p>Unlike <code>em.utils</code>, this package generally limits its contents to what we'll term as global proxies \u2013 a set of well-known modules that implement certain <code>em.hal</code> interfaces by effectively forwarding function calls to a conformant delegate; <code>ConsoleUart</code> and <code>Poller</code> illustrate this pattern. This package also contains the widely-used <code>Common</code> module, which conveniently aggregates additional global proxies into a single unit.</p> em.lang <p>Invisible to most clients, this package helps bootstrap the implementation of the EM language itself through several distinguished interfaces declaring intrinsic configs and functions:\u00a0  <code>ModuleI</code>, that all modules or interfaces will inherit; <code>CompositeI</code>, that all composites will inherit; and <code>TemplateI</code>, that all templates will inherit. This package also contains the <code>Console</code> module and its <code>ConsoleProviderI</code> interface \u2013 supporting <code>printf</code> statements innate to the language. Finally, this package houses common C\u2009/\u2009C++ and JavaScript code fragments interpolated during the EM program build-flow.</p> <p>Using EM will take a more detailed look at the source code of specific\u2009<code>.em</code> files found in the first three of these packages.</p>"},{"location":"intro/to-4/#target-specific-content","title":"Target-specific content","text":"<p>Complementing <code>em.core</code> and its portable packages, the <code>ti.cc23xx</code> bundle delivers support for the Texas Instruments CC2340R5 wireless MCU.  While specifically targeting a particular MCU family, the organization of the packages found within the <code>ti.cc23xx</code> bundle follows a pattern generally seen within any EM distro.</p> ti.distro.cc23xx <p>This package (and in fact the entire <code>ti.cc23xx</code> distro bundle) revolves around a single composite conventionally named <code>BoardC</code> \u2013 responsible for configuring parameters as well as binding proxies exposed by elements of <code>em.core</code>. This package also contains two other conventionally named units found in any EM distro:\u00a0 the <code>McuC</code> composite, which (in this case) focuses on the <code>ti.mcu.cc23xx</code> package; and the special <code>host</code> <code>BoardMeta</code> module, which effectively defines the schema of the board-specific YAML file mentioned earlier in the context of configuration and pre-configuration. </p> ti.mcu.cc23xx <p>Many of the modules in this package provide MCU-specific implementations of abstract interfaces found in <code>em.hal</code> \u2013 <code>ConsoleUart0</code>, <code>Idle</code>, <code>OneShotGpt3</code>, and others.  Likewise, this package features templates such as <code>GpioT</code> and <code>InterruptT</code> whose <code>em$generateUnit</code> intrinsics synthesize MCU-specific implementations of other HAL interfaces at program build-time.  Finally, this package contains even lower-level auxiliary modules (eg, <code>Regs</code> and <code>Rtc</code>) whose clients typically remain within the distro itself.</p> ti.build.cc23xx <p>This package contains <code>host</code> modules that control the compiling\u2009/\u2009linking of target EM programs using a particular C\u2009/\u2009C++ toolchain.  The modules typically pass target-specific information such as memory maps or register declarations to generic modules found in a special <code>em.build</code> bundle, which we'll discuss in a later document.</p> <p>Porting EM will dive into virtually all of the\u2009<code>.em</code> source files found in these three packages, as well as explore the <code>em.build</code> bundle mentioned above.</p>"},{"location":"intro/to-4/#elementary-programs","title":"Elementary programs","text":"<p>The  em.examples.basic package within the <code>em.docs</code> bundle contains a curated set of programs described at length in Using EM.  A live sequence of \"guided tours\" that view\u2009/\u2009build\u2009/\u2009load these programs revolve around the following modules:</p> HelloP hello world Tour 00 BlinkerP basic blinker Tour 01 BlinkerDbgP real-time debug Tour 02 FiberP threading with fibers Tour 03 Button1P button handlers Tour 04 Button2P button fibers Tour 05 Button3P button objects Tour 06 OneShot1P timer handlers Tour 07 OneShot2P timer fibers Tour 08 PollerP timer service Tour 09 Alarm1P wakeup alarms Tour 10 Alarm2P aligned wakeups Tour 11 TickerP cyclic tickers Tour 12 <p>To ensure their portability, none of these programs explicitly reference the \"current\" EM distro package [\u2009<code>ti.distro.cc23xx</code>\u2009] by name; rather, these programs use a special language intrinsic [\u2009<code>em$distro</code>\u2009] as a logical name which you will bind to a particular distro package.</p>"},{"location":"intro/to-4/#learning-more-em","title":"Learning more EM","text":"<p>If you want to learn more about EM \u2013 but continue to fly at 10,000' for now \u2013 we strongly recommend reading through Using EM to get a sense for the platform's tooling and runtime from a ground-level perspective; a quick pass through the other documents at this site should prove informative as well.</p> <p>When you want to hit the ground running and start coding, however, you'll definitely need to first work through Installing EM before proceeding onward to Using EM.  Both of these documents also accomodate a special **\u2009FAST-TRACK\u2009** option, which enables you to rapidly experience the EM development environment as well as learn more about  em.core.</p> <p>The Porting EM document continues on the ground, exploring the  ti.cc23xx bundle in greater detail as well as outlining the steps required to create new EM distros that support other MCUs.  Over time, we expect Porting EM will draw upon a broader set of distro bundles to further reinforce the EM platform's architecture for encapsulating target-specific content.</p> <p>Finally, Advancing EM contains an ever-growing collection of standalone articles addressing a wide-range of topics about EM.  While many of these articles expect that you've already spent time on the ground coding, others presume just a 10,000' understanding of Using EM.</p> <p>Case in point:\u00a0\u00a0 we strongly recommend the Energy Consumption article, which presents further evidence supporting a hypothesis about EM put forth earlier.</p> <p>Happy coding\u2009!!! \u2002 </p>"},{"location":"porting/","title":"Managing hardware diversity in EM","text":"<p>Under Construction \u2014 estimated completion in 1Q24 \u2009 </p> <p></p>"},{"location":"using/","title":"Writing portable applications in EM","text":"<p>If you've made it this far, let's hit the ground running and starting coding\u2009!!!\u00a0\u00a0  This document will first familiarize you with the mechanics of viewing, editing, building, and loading EM programs and their constituent units using the EM Builder extension for VS Code. If you haven't worked with VS Code, the web abounds with tutorials\u2009+\u2009references for this ever-popular IDE.</p> <p>The main portion of this document comprises a series of tours that visit some basic programming examples \u2013 curated to introduce elements of the EM runtime environment, as well as to reinforce common coding idioms of the EM language(1).  To support these documentation resources, EM Builder includes a \"tour guide\" utility that walks you through this material in a somewhat specialized fashion.</p> <ol> <li>consult Language Syntax as a reference</li> </ol> <p>If you've chosen to bypass Installing EM for now, a quick read through this document would still have benefit \u2013 even if you can't execute real software on real hardware.</p> <p>If you have elected to install EM Builder \u2013 but haven't received your hardware or else prefer the **\u2009FAST-TRACK\u2009** option \u2013 you can still build the programs featured in any of the tours.  Until your board arrives and you can actually load these programs, studying the logic capture(s) associated with each example should help bridge the gap.</p> <p>These captures in fact reveal subtle timing details otherwise invisible to the naked eye.</p> <p>We've generated all of the captures presented later in this document using a Saleae Logic Analyzer \u2013 in our opinion, the single most valuable tool for \"debugging\" real-time embedded software running on target MCU hardware. At a minimum, you should download the (free) Saleae Logic 2 software and explore these logic capture files off-line.</p> If you can't see the problem, you can't fix it\u2009!!! <p>Software debuggers have traditionally focused upon a rich presentation of program state (variables, call stacks, peripherals) \u2013 but only after program execution halts (say) upon reaching a breakpoint.  Given the general nature of embedded software, however, a dynamic presentation depicting state-changes over time proves far more helpful for troubleshooting real-world problems.</p> <p>While modern debuggers attempt to address this need, they often do so by introducing significant amounts of hardware\u2009/\u2009software overhead \u2013 limiting their utility to software development rather than system deployment.  These approaches may also preclude the underlying MCU from entering its \"deep-sleep\" mode \u2013 a serious limitation that can obscure real-world, real-time wakeup issues.</p> <p>But armed with no more than a basic logic analyzer, the EM language provides intrinsic \"real-time debug\" capabilities that enable us to dynamically capture program state without incurring excessive program overhead.  In the spirit of \"test what you fly, fly what you test\", these capabilities prove equally valuable during development in the factory and well as during deployment in the field.</p> <p>At the same time, we also want you to experience the joy of blinking LEDs\u2009!!!\u00a0\u00a0  With that, let's first skill-up on EM Builder and then tour the EM runtime.\u00a0</p> <p>When finished, circle back to Learning more EM and plan your next adventure.</p> <p></p>"},{"location":"using/using-01/","title":"Working with EM Builder","text":"<p>To flatten your learning curve, we'll work exclusively within the VS Code environment \u2013 using the EM Builder extension which you've already installed.  Besides introducing some core capabilities of the extension, the material that follows will also verify the integrity of your installation.</p> But what about the command line\u2009??? <p>Strictly speaking, we don't need VS Code to develop EM software:\u00a0 you can create folders\u2009/\u2009files as you always have; you can create\u2009/\u2009modify\u2009<code>.em</code> sources in your favorite text editor; and you can build\u2009/\u2009load executable EM programs using the <code>em-cli</code> command-line interface.\u00a0  The implementation of EM Builder and <code>em-cli</code>, in fact, share quite a bit of common code \u2013 with the former often invoking the latter.  The Command-line inteface reference material describes the <code>em-cli</code> tool in greater detail.</p>"},{"location":"using/using-01/#workspace-organization","title":"Workspace organization","text":"<p>The following animation illustrates the overall organization of your workspace folder when using the EM Builder extension, and picks up from where we left off when Installing EM.\u2009  We also encourage you to launch VS Code by entering <code>code</code> <code>workspace</code> from your PC's shell, and to simultaneously explore this environment at your own pace.</p> <p></p> <p></p> VS Code Screen Layout <p></p> <p></p> VS Code Screen Layout"},{"location":"using/using-01/#building-em-programs","title":"Building EM programs","text":"<p>The following animation illustrates how to build <code>HelloP.em</code> using the EM - Build command, selected from this file's (right-click) context menu.  Since this program contains a main <code>em$run</code> function, the EM translator produces a corresponding executable image; see the OUTPUT panel for details.</p> <p></p> <p></p> EM - Build <p></p> <p></p> EM - Build"},{"location":"using/using-01/#loading-em-programs","title":"Loading EM programs","text":"<p>The following animation illustrates how to load the previously-built <code>HelloP.em</code> program using the EM - Load command \u2013 also selected from a context menu.  Should loading the executable image fail for some reason (eg, you don't even have a target board), an error message would appear in the OUTPUT panel.</p> <p></p> <p></p> EM - Load <p></p> <p></p> EM - Load"},{"location":"using/using-01/#monitoring-em-programs","title":"Monitoring EM programs","text":"<p>The following animation illustrates how to monitor any <code>printf</code> output from the currently loaded program image, by invoking EM - Open Console within the VS Code Command Palette\u2009.  Once the special TERMINAL panel has launched, press the RESET button on your target board and enjoy the show\u2009!!!</p> <p></p> <p></p> EM - Open Console <p></p> <p></p> EM - Open Console"},{"location":"using/using-01/#creating-em-artifacts","title":"Creating EM artifacts","text":"<p>The following animation illustrates how to create a workspace bundle using the EM - New Bundle command, likewise found in the Command Palette\u2009.  In this case, we've named the new artifact as <code>my.bundle</code>; the remainder of this document will often refer to this folder as your \"personal\" bundle.</p> <p></p> <p></p> EM - New Bundle <p></p> <p></p> EM - New Bundle <p>The following animation illustrates how to populate your personal bundle folder with other EM artifacts \u2013 packages, modules, interfaces, etc \u2013 created using commands selected from the (right-click) context menu of the containing folder.  In this case, we'll invoke EM - New Package followed by EM - New Test Program to create a unit named <code>my.pkg/Test</code>.</p> <p></p> <p></p> EM - New Package | EM - New Test Program <p></p> <p></p> EM - New Package | EM - New Test Program"},{"location":"using/using-01/#cloning-em-cargo","title":"Cloning EM cargo","text":"<p>The following animation illustrates the EM - Clone command, used to populate personal bundles with runtime content delivered by the EM Builder extension and housed under the special\u2009<code>.em-cargo</code> folder.  In this case, we'll first locate <code>em.examples.basic/FiberP</code> and <code>em.utils/FiberMgr</code> under\u2009<code>.em-cargo</code> and then clone these units into <code>my.bundle</code>.</p> <p></p> <p></p> EM - Clone <p></p> <p></p> EM - Clone"},{"location":"using/using-01/#exploring-em-sources","title":"Exploring EM sources","text":"<p>The following animation illustrates a few of the VS Code language features supported by the EM Builder extension.  In this case, we'll hover over EM identifiers and jump between\u2009<code>.em</code> source files; we'll also use the OUTLINE panel to navigate amongst the declarations\u2009/\u2009definitions contained within individual EM units.</p> <p></p> <p></p> VS Code Language Support <p></p> <p></p> VS Code Language Support <p>While these capabilities prove helpful when exploring EM source code, the EM Builder extension also provides support for \"smart completion\" (IntelliSense) \u2013 even more helpful when editing your code.\u00a0  At the same time, VS Code language support remains a never-ending journey of incremental improvement.</p> <p>Help wanted \u2013 VS Code programmer</p> <p></p>"},{"location":"using/using-02/","title":"Programming with EM","text":"<p>Turning now to the EM runtime, a series of curated \"guided tours\" will incrementally introduce components of the  em.core bundle \u2013 many of which you may have browsed in your reading of Introducing EM.\u2009  By convention, each tour revolves around a specific EM program found in the  em.examples.basic package \u2013 with each of these small programming examples motivating us to visit key elements of the EM runtime.</p> <p>In the material that follows, we'll reference a number of logical MCU \"pins\" configured by the current EM distro and generally accessible through headers on your target board:</p> <code>\u2003\u2003\u2003\u2003\u2003appBut</code> application button pin <code>\u2003\u2003\u2003\u2003\u2003appLed</code> application LED pin (usually green) <code>\u2003\u2003\u2003\u2003\u2003appOut</code> application console TX pin <code>\u2003\u2003\u2003\u2003\u2003sysDbgA</code> system debug pin A <code>\u2003\u2003\u2003\u2003\u2003sysDbgB</code> system debug pin B <code>\u2003\u2003\u2003\u2003\u2003sysDbgC</code> system debug pin C <code>\u2003\u2003\u2003\u2003\u2003sysDbgD</code> system debug pin D <code>\u2003\u2003\u2003\u2003\u2003sysLed</code> system LED pin (usually red) <p>A special YAML file named <code>em-boards</code> found the <code>em$distro</code> package folder binds these logical pin names to physical pin numbers of your target board.  Porting EM will have more to say about <code>em-boards</code>, as well as explain the special <code>setup-*.properties</code> files located in the root of your distro bundle. </p>"},{"location":"using/using-02/#tour-00-guided-tours","title":"Tour 00 \u2013 guided tours","text":"<p>The following animation illustrates the EM - Start Tour command, which you'll use to view each of the tours described in the remainder of this document.  You'll find these tours in appropriately named\u2009<code>.emtour</code> files, located inside the\u2009<code>.tours/101_Using_EM</code> folder delivered with the <code>em.docs</code> bundle.</p> <p></p> <p></p> EM - Start Tour <p></p> <p></p> EM - Start Tour <p>With that, go ahead and actually take tour <code>00_HelloP.emtour</code> within your VS Code environment.  Before proceeding to take Tour 01\u2009\u2013\u2009Tour 12\u2009, however, you should feel comfortable with the UI presented in Tour 00\u2009; and do retake any of these tours whenever necessary.</p>"},{"location":"using/using-02/#tour-01-basic-blinker","title":"Tour 01 \u2013 basic blinker","text":"<p>This tour centers around the  BlinkerP program, which  toggles the <code>appLed</code> pin on your target board \u2013 typically connected to a green LED.  This tour also visits the  BusyWaitI and  LedI interfaces, as well as presents the  Common module and its constituent proxies.</p> <p></p> Tour 01 \u2013 Logic Capture   <p> \u00a0 The EM runtime quickly blinks your board's <code>sysLed</code> at startup.</p> <p> \u00a0 The <code>BlinkerP</code> program toggles <code>appLed</code> every ~0.5\u2009s.</p> <p> \u00a0 The EM runtime turns on <code>sysLed</code> upon normal program termination.</p> <p> \u00a0 The next capture zooms into the <code>appOut</code> signal.</p> <p></p> Tour 01 \u2013 Logic Capture (zoom)   <p> \u00a0 The EM runtime outputs this sequence of (non-printable) bytes at startup, after blinking <code>sysLed</code>.</p> <p> \u00a0 The EM runtime output this single byte upon normal program termination, before turning on <code>sysLed</code>.</p>"},{"location":"using/using-02/#tour-02-real-time-debug","title":"Tour 02 \u2013 real-time debug","text":"<p>This tour focuses upon the  BlinkerDbgP program, which also toggles the <code>appLed</code> pin on your target board.  This tour highlights a number of capabilities within EM for visualizing and troubleshooting program execution in real-time.</p> <p></p> Tour 02 \u2013 Logic Capture  <p> \u00a0 The busy-wait bracketed by <code>%%[d+]</code> and <code>%%[d-]</code> measures ~498 ms. </p> <p> \u00a0 Executing a <code>fail</code> statement causes <code>sysLed</code> to blink rapidly. </p> <p></p> Tour 02 \u2013 Logic Capture (zoom)   <p> \u00a0  The <code>%%[&gt;cnt]</code> statement outputs the (non-printable) <code>0x82</code> control byte followed by 2 bytes of payload.</p> <p> \u00a0  The <code>%%[&gt;bits11]</code> statement outputs the (non-printable) <code>0x81</code> control byte followed by 1 byte of payload.</p> <p> \u00a0  The <code>%%[c:bits11]</code> statement causes the <code>dbgC</code> pin to rapidly toggle 2 times \u2013 since <code>(bits11\u2009==\u20090x1)</code></p> <p> \u00a0  The ASCII character output of <code>printf</code> begins here \u2013 <code>0x63('c')</code>,  <code>0x6E('n')</code>, and so on.</p>"},{"location":"using/using-02/#tour-03-threading-with-fibers","title":"Tour 03 \u2013 threading with fibers","text":"<p>This tour centers around the  FiberP program, which introduces a very lightweight threading construct termed a fiber.  This tour also visits the EM runtime's (portable) implementation of fibers found in the  FiberMgr module.</p> <p></p> Tour 03 \u2013 Logic Capture   <p> \u00a0 The <code>%%[d]</code> statement in <code>blinkFB</code> marks each point in time where the <code>blinkF</code> fiber begins execution.</p> <p> \u00a0 The ~200 ms between <code>blinkF</code> cycles includes <code>appLed</code> on\u2009/\u2009off time plus <code>FiberMgr</code> dispatch overhead.</p>"},{"location":"using/using-02/#tour-04-button-handlers","title":"Tour 04 \u2013 button handlers","text":"<p>This tour centers around the  Button1P program, which handles incoming events generated when pressing <code>appBut</code> on your board.  This tour also visits the  GpioEdgeDetectMinI interface that in turn extends the  GpioI abstraction.</p> <p></p> Tour 04 \u2013 Logic Capture   <p> \u00a0 The EM runtime uses <code>dbgB</code> to mirror the MCU's execution mode [\u2009L \u2013 actively running, H \u2013 awaiting wakeup\u2009]</p> <p> \u00a0 Pressing your board's button drives the <code>appBut</code> pin low; <code>appLed</code> then blinks shortly thereafter.</p> <p> \u00a0 A 125\u2009ns \"glitch\" on the <code>appBut</code> signal fired another event at this time \u2013 causing an extra <code>appLed</code> blink.</p> <p></p> Tour 04 \u2013 Logic Capture (zoom)   <p> \u00a0 You've pressed <code>appBut</code> at this time, which then begins awakening the MCU from its low-power sleep.</p> <p> \u00a0 Requiring 34.2\u2009\u03bcs to fully power the MCU, <code>dbgB</code>'s falling edge marks when <code>Button1P</code> starts actively running.</p> <p> \u00a0 Control enters <code>handler</code> within 3.4\u2009\u03bcs, whose initial <code>%%[c]</code> statement toggles <code>dbgC</code> for 1.2\u2009\u03bcs</p> <p> \u00a0 After some housekeeping, <code>Button1P</code> finally turns-on <code>appLed</code> \u2013 5.9\u2009\u03bcs since actively running.</p>"},{"location":"using/using-02/#tour-05-button-fibers","title":"Tour 05 \u2013 button fibers","text":"<p>This tour centers around the  Button2P program, which uses a <code>Fiber</code> object to better handle incoming events.  This tour also analyzes the performance impact of this approach compared with the earlier  Button1P program.</p> <p></p> Tour 05 \u2013 Logic Capture   <p> <code>dbgB</code> shows that <code>Button2P</code> awoke exactly twice in response to pressing <code>appBut</code> \u2013 no glitches this time\u2009!!!</p> <p></p> Tour 05 \u2013 Logic Capture (zoom)   <p> <code>Button2P</code> resumes execution in 35.2\u2009\u03bcs; keep in mind that low-power MCU wakeup times can vary slightly. </p> <p> \u00a0 Control then enters <code>handler</code> 3.4\u2009\u03bcs later \u2013 consistent with the <code>Button1P</code> capture seen above.</p> <p> \u00a0 Unlike <code>Button1P</code>, the <code>Button2P</code> <code>handler</code> readies the <code>blinkF</code> fiber which then gains control 5.3\u2009\u03bcs later.</p> <p> \u00a0 Finally, the <code>blinkFB</code> function turns-on <code>appLed</code> \u2013 with only ~5\u2009\u03bcs of <code>FiberMgr</code> scheduling overhead.</p>"},{"location":"using/using-02/#tour-06-button-objects","title":"Tour 06 \u2013 button objects","text":"<p>This tour centers around the  Button3P program, which debounces button input signals in a portable fashion.  This tour also visits the  ButtonI interface along with a module implementing this interface \u2013 the latter generated by the  ButtonT template at build-time.</p> <p></p> Tour 06 \u2013 Logic Capture   <p> \u00a0 Once triggered by pressing your board's button, the EM runtime polls the state of <code>appBut</code> every 100\u2009ms. </p> <p> \u00a0 If pressed for \u2265\u2009100\u2009ms but \u2264\u20094\u2009s, <code>Button3P</code> will blink <code>appLed</code> within 100\u2009ms of releasing the button.</p> <p> \u00a0 Hitting the 4\u2009s mark, <code>Button3P</code> immediately blinks <code>sysLed</code>\u2013 regardless of how long <code>appBut</code> remains low.</p> <p></p> Tour 06 \u2013 Logic Capture (zoom)   <p> \u00a0 After polling <code>appBut</code> for 4\u2009s, the EM runtime invokes <code>Button3P.onPressedCB</code> which leaves a <code>%%[c]</code> mark.</p> <p> \u00a0 Discovering that <code>appBut</code> remains pressed [\u2009=\u2009L\u2009], <code>onPressedCB</code> then blinks <code>sysLed</code> for 40\u2009ms.</p> <p> \u00a0 Only 7.5\u2009\u03bcs elapses from <code>dbgB</code> falling to <code>sysLed</code> rising, which includes scheduling fibers plus 1.2\u2009\u03bcs for <code>%%[c]</code>.</p>"},{"location":"using/using-02/#tour-07-timer-handlers","title":"Tour 07 \u2013 timer handlers","text":"<p>This tour centers around the  OneShot1P program, which handles timer events that awaken the MCU.  This tour also visits the  OneShotMilliI interface, which abstracts the functionality of a short-term timer with millisecond resolution.</p> <p></p> Tour 07 \u2013 Logic Capture   <p> \u00a0 The <code>dbgB</code> signal shows that <code>OneShot1P</code> awakens from low-power sleep every 500\u2009ms.</p> <p> \u00a0 Once awake, <code>OneShot1P</code> toggles <code>dbgC</code> and <code>dbgD</code> before blinking <code>appLed</code> \u2013 like our earlier <code>Button1P</code> capture</p> <p> \u00a0 The 7.5\u2009\u03bcs \"wakeup-to-blink\" latency seen here includes the overhead of servicing an on-chip MCU timer.</p>"},{"location":"using/using-02/#tour-08-timer-fibers","title":"Tour 08 \u2013 timer fibers","text":"<p>This tour centers around the  OneShot2P program, which now uses <code>Fiber</code> objects to enhance robustness when handing timer events.  This tour also invites performance comparision with the earlier  OneShot1P program.</p> <p></p> Tour 08 \u2013 Logic Capture   <p> \u00a0 Fiber scheduling adds the extra 1.1\u2009\u03bcs of latency seen here, compared with our previous <code>OneShot1P</code> capture. </p>"},{"location":"using/using-02/#tour-09-timer-service","title":"Tour 09 \u2013 timer service","text":"<p>This tour centers around the  PollerP program, which introduces a portable function for pausing execution at run-time.  This tour also visits the top-level  Poller module as well as the lower-level  PollerAux module \u2013 both implementing the  PollerI interface.</p> <p></p> Tour 09 \u2013 Logic Capture   <p> \u00a0 Without <code>%%[c]</code> and <code>%%[d]</code> marks, <code>PollerP</code> further reduces latency compared to <code>OneShot1P</code> and <code>OneShot2P</code>.</p> <p></p> Tour 09 \u2013 Logic Capture (zoom)   <p> \u00a0 The [L] <code>dbgB</code> signal indicates that the <code>PollerP</code> program has awoken.</p> <p> <code>PollerP</code> then calls <code>AppLed.wink</code> within 2.5\u2009\u03bcs, which then asserts the <code>appLed</code> pin</p> <p> \u00a0 Calling <code>AppLed.wink</code> 2.5\u2009\u03bcs later asserts the <code>appLed</code> pin and then internally invokes <code>Poller.pause</code>.</p> <p> <code>Poller.pause</code> proceeds to suspend program execution for 5\u2009ms \u2013 the duration of the wink.</p> <p> \u00a0 The EM runtime toggles <code>dbgB</code> once before awaiting the next wakeup [H]\u2009; we'll explain more in a later tour.</p> <p> \u00a0 An MCU timer event will eventually awaken the program 5\u2009ms later, with <code>dbgB</code> now signalling [L]\u2009.</p> <p> \u00a0 Control unwinds from <code>Poller.pause</code> back to <code>AppLed.wink</code>, which will now lower the <code>appLed</code> pin.</p> <p> <code>em$run</code> finally regains control, and then suspends execution for 500\u2009ms by calling <code>Poller.pause</code> directly.</p>"},{"location":"using/using-02/#tour-10-wakeup-alarms","title":"Tour 10 \u2013 wakeup alarms","text":"<p>This tour centers around the  Alarm1P program, which uses <code>Alarm</code> objects to schedule longer-term wakeups with (sub-)second resolution.  This tour also visits the  AlarmMgr module, which internally uses a proxy implementing the  WakeupTimerI interface.</p> <p></p> Tour 10 \u2013 Logic Capture   <p> \u00a0 The <code>Alarm1P</code> program alternately awakens from a low-power deep-sleep of 2\u2009s or else 750\u2009ms in duration.</p> <p> \u00a0 The program's <code>blinkFB</code> function winks <code>appLed</code> for 100\u2009ms, with the MCU idling in the interim.</p> <p> \u00a0 Once <code>AppLed.wink</code> returns, <code>Alarm1P</code> calls <code>alarm.wakeup</code> to re-enter an extended period of deep-sleep.</p> <p></p> Tour 10 \u2013 Logic Capture (zoom)  <p> \u00a0 The single <code>dbgB</code> mark indicates the MCU has entered its \"lite-sleep\" mode, after <code>Alarm1P</code> calls <code>AppLed.wink</code></p> <p> \u00a0 The MCU awakens from its lite-sleep within 100\u2009ms, returning to <code>wink</code> which then turns-off <code>appLed</code>.</p> <p> \u00a0 The double <code>dbgB</code> mark indicates the MCU has entered its \"deep-sleep\" mode, after calling <code>alarm.wakeup</code></p>"},{"location":"using/using-02/#tour-11-aligned-wakeups","title":"Tour 11 \u2013 aligned wakeups","text":"<p>This tour centers around the  Alarm2P program, which now aligns <code>Alarm</code> wakeups with a given time-window.  This tour also re-visits the  AlarmMgr implementation, seeing how it schedules the next wakeup event as well as the role played by the  EpochTime module.</p> <p></p> Tour 11 \u2013 Logic Capture   <p> \u00a0 Note how the wakeups from deep-sleep align with a series of 1.5\u2009s windows along the time-line.</p> <p> \u00a0 Due to startup overhead, the first <code>alarm.wakeup</code> call deep-sleeps the MCU for only 1.250\u2009s to stay aligned.</p> <p> \u00a0 After a 5\u2009ms <code>appLed</code> wink, this <code>alarm.wakeup</code> call deep-sleeps the MCU for 1.495\u2009s to stay aligned.</p> <p> \u00a0 But after a 100\u2009ms wink, this <code>alarm.wakeup</code> call deep-sleeps the MCU for just 1.400\u2009s to stay aligned.</p>"},{"location":"using/using-02/#tour-12-cyclic-tickers","title":"Tour 12 \u2013 cyclic tickers","text":"<p>This tour centers around the  TickerP program, which takes duty-cycled functions to a higher level. This tour also visits the  TickerMgr module, whose implementation of <code>Ticker</code> objects emulates as well as builds upon the  AlarmMgr and  FiberMgr studied earlier.</p> <p></p> Tour 12 \u2013 Logic Capture   <p> \u00a0 The <code>appTicker.start</code> call by the <code>TickerP</code> program initiates a train of 100\u2009ms <code>appLed</code> winks, spaced 1\u2009s apart.</p> <p> \u00a0 The <code>sysTicker.start</code> call by <code>TickerP</code> then initiates a train of 100\u2009ms <code>sydLed</code> winks, but spaced 1.5\u2009s apart.</p> <p> \u00a0 When <code>appTicker</code> and <code>sysTicker</code> wakeups coincide, their callbacks run on a first-come, first-served basis.</p> <p></p>"}]}